<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.16">
<title>The COMIT II Manual</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;-webkit-tap-highlight-color:transparent}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="article">
<div id="header">
<h1>The COMIT II Manual</h1>
</div>
<div id="content">
<div class="sect1">
<h2 id="_about_this_manual">About This Manual</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This COMIT manual is derived from the text of the book "Programming
with COMIT II" by Victor H. Yngwe, MIT Press 1972.  Book material
is reproduced here for educational and research purposes; all
copyrights remain with publisher and/or the author&#8217;s heirs (he died
in 2012). This text is not for sale and should be distributed with
the open-source COMIT interpreter only.</p>
</div>
<div class="paragraph">
<p>Because the purpose of this manual is strictly to document the COMIT II
language, various scholarly apparatus has been jettisoned, including
an introductory chapter on program decomposition and a bibliography.
Material that wandered too far afield into linguistics or the
mechanics of a programming-language course in 1972 has also been
omitted.  So have a few simple flowcharts, fashionable accessories
that were taken to signify an air of seriousness in a programming
text of that time but conveyed little information even then.</p>
</div>
<div class="paragraph">
<p>In a few notes that refer specifically to the implementation this manual ships
with, it is referred to as "COMIT Revived".)</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_historical_context">Historical Context</h2>
<div class="sectionbody">
<div class="paragraph">
<p>COMIT, dating from 1957, was the very first computer language designed
for string processing.  It was originally designed for early work in
automated translation of natural languages. In this role it (and other
similar and slightly later efforts such as TRAC) were, alas, largely
failures; neither the naive text-transformation theory of the time nor
the computing power available was adequate to the job. The first
really high-quality computer translations would not become public
until nearly fifty years later, and use statistical fuzzy-matching
methods very different in style from COMIT&#8217;s.</p>
</div>
<div class="paragraph">
<p>Nevertheless, COMIT cast a long shadow.  Text transformation turned
out to be a valuable tool for domains less messy than natural
languages.  The first really successful language in this class,
SNOBOL, inherited some central concepts and terminology from COMIT.
Through SNOBOL these would propagate into the ed(1) and sed(1)
utilities; this is why older versions of sed documentation used
the term "workspace" for what is now often called "pattern space".
What passes for control flow in sed(1) - fall through or branch to
label - is also inherited from COMIT.  Another relic of COMIT is the
use of $1 $2 &#8230;&#8203; $n as magic string variables.</p>
</div>
<div class="paragraph">
<p>Accordingly, every Unix scripting language from shell through early
Awk and Perl to Python and onward owes a significant debt to COMIT.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_basic_notions_of_comit">THE BASIC NOTIONS OF COMIT</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_2_1_comit_data_structure">2.1 COMIT Data Structure</h3>
<div class="paragraph">
<p>§2.1.0.0 Data as it is submitted to a COMIT program is in the form of
strings of characters just as they are punched on cards or typed on
the typewriter.  The output that a COMIT program produces is also in
the form of strings of characters, which are printed, punched, or
stored for further use. The function of the COMIT program is to
operate on strings of characters. It can perform grouping,
rearranging, inserting, deleting, sorting, testing, tagging, counting,
and so forth. To facilitate these manipulations in a computer,
characters are organized into groups called <em>constituents</em>. For example,
if the input data consists of text punched on cards, the data can be
brought into the computer simply as a string of characters. But it
might be more convenient for some purposes to organize the characters
of the text into constituents representing individual words. In the
COMIT language, the boundaries between constituents are represented
by plus signs. For example, if the following words were punched on a
card and presented to a COMIT program as data,</p>
</div>
<div class="listingblock">
<div class="content">
<pre>THIS IS DATA.</pre>
</div>
</div>
<div class="paragraph">
<p>they could be read in and grouped one character per constituent for further
processing:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>T + H + I + S + - + I + S + - + D + A + T + A + . + *.</pre>
</div>
</div>
<div class="paragraph">
<p>where the hyphens represent spaces and the constituent *. is an end-of-line
symbol. It could equally well be brought in with the letters compressed into
one word per constituent:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>THIS + IS + DATA + . + *.</pre>
</div>
</div>
<div class="paragraph">
<p>or with spaces not deleted:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>THIS + - + IS + - + DATA + . +.*.</pre>
</div>
</div>
<div class="paragraph">
<p>§2.1.0.1 When data is read into the computer by a COMIT program, it
enters an area of storage called the <em>workspace.</em> The COMIT workspace is
that area of storage in which most of the data manipulations take
place. Figure 1 shows how the workspace occupies a central position
with respect to data flow. Data can flow into the workspace from the
input and from the program, out from the workspace to the output,
and back and forth between the workspace and the auxiliary storage
areas called the dispatcher and the shelves. The data in the
dispatcher is</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/flowdiagram.png" alt="flowdiagram">
</div>
<div class="title">Figure 1. Figure 1. Data flow within the computer during the execution of a COMIT program.</div>
</div>
<div class="paragraph">
<p>normally used to specify which branches the flow of control is to
take, and will be described in more detail in later chapters. The
shelves are mainly used to hold data temporarily while it is not being
worked on. Shelf zero also functions to hold the automatic subroutine
return pushdown. The flow of data between the workspace and the other
areas of storage is under the control of the COMIT program that has
previously been read into the computer. It is the program, too, that
specifies the various manipulations that are to be carried out
on the data in the workspace.</p>
</div>
</div>
<div class="sect2">
<h3 id="_2_2_form_of_comit_program">2.2 Form of COMIT Program</h3>
<div class="paragraph">
<p>§2.2.0.0 The main part of the COMIT program consists of instructions
for moving and manipulating the data and for directing the flow of
control. These instructions are called rules. In other computer
languages, an instruction may be called a statement. Normally, COMIT
rules are punched one to a card, and are submitted to the computer
between a special title card and an end card.  When the program is
being executed by the computer, the rules are executed one at a time,
with the flow of control going from rule to rule according to
directions written in the rules and subject to the outcome of various
tests made on the data.</p>
</div>
<div class="paragraph">
<p>§2.2.0.1 A COMIT rule has five sections and can be represented schematically
as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>name left-half = right-half // routing go-to</pre>
</div>
</div>
<div class="paragraph">
<p>§2.2.1 <strong>The NAME Section</strong> The name section serves to identify the rule
for the purposes of flow of control. Control can be directed to a rule
from any other rule in the program by means of its rule name. If a
rule does not need a name, an asterisk is written in the name section.</p>
</div>
<div class="paragraph">
<p>§2.2.2 <strong>The LEFT-HALF</strong> The left-half serves to specify the data in the
workspace that is to be manipulated. It does this by a left-to-right
search of the constituents in the workspace. For example, if the
expression</p>
</div>
<div class="listingblock">
<div class="content">
<pre>A + B</pre>
</div>
</div>
<div class="paragraph">
<p>is written in the left half, it causes the workspace to be searched
from left to right for the first occurrence of two adjacent
constituents A and B. If the search is successful, the two workspace
constituents found are given temporary numbers 1 and 2 for later
reference in the rule, and the rest of the rule is executed. But if
the search is unsuccessful, there being no matching constituents in
the workspace, the rule is said to fail. It does not apply, and the
rest of the rule is not executed. Instead, control goes to the next
rule in sequence, that is, the next rule below in the deck of
cards. Thus the left-half also serves as a test that can control the
flow of control and can be used, for example, to terminate a loop when
there remains no more data to be operated on.</p>
</div>
<div class="paragraph">
<p>§2.2.3 <strong>The RIGHT-HALF</strong> The right-half expresses the operations that are to be
carried out on the data found. For example, if the left-half search has found
Vtwo constituents A and B in the workspace and has temporarily numbered them 1
and 2, the right-half expression 2 + 1, referring by means of these numbers to
the workSpace constituents found, would cause the two constituents found to be
interchanged, that is replaced by the second one followed by the first one.</p>
</div>
<div class="paragraph">
<p>§2.2.4 <strong>The ROUTING Section</strong> The routing section of the rule contains
input and output instructions, instructions for routing the data
between the workspace and the shelves, and some other miscellaneous
instructions, such as instructions for compressing several workspace
constituents into one or for expanding a constituent into several, one
for each character.</p>
</div>
<div class="paragraph">
<p>§2.2.5 <strong>The GO-TO Section</strong> The go-to section is for flow of control. Here may
be written the name of the rule to which control is to be transferred. There
are several other types of go-to expressions. The most frequently used is the
asterisk, which sends control to the next rule in sequence. A fraction bar (/)
sends control back to the same rule again.</p>
</div>
<div class="paragraph">
<p>§2.2.6 <strong>Punctuation of the COMIT Rule</strong> A name section in a rule is required. It
begins in column 1 at the extreme left of the card and is separated from the
rest of the rule by one or more spaces. A go-to is required. It is the last
string of nonspace characters on the card and is separated from the rest of
the rule by one or more spaces. The other sections are optional except that
some sections require others; a right-half requires a left-half, for example.
A left-half is terminated by an equal sign and optional spaces. A routing
section is introduced by two fraction bars. Additional optional spaces are
allowed anywhere in the COMIT rule where a single Space is allowed or required</p>
</div>
</div>
<div class="sect2">
<h3 id="_2_3_manipulating_data_in_the_workspace">2.3 Manipulating Data in the Workspace</h3>
<div class="paragraph">
<p>§2.3.0.0 The various parts of the rule are executed in left-to-right sequence.
Under control of the left-half and the right-half, data in the workspace can
be tested and manipulated. Data can be replaced, rearranged, inserted, deleted,
and duplicated. In this section, some basic left-half and right-half operations
will be presented. A more detailed presentation of the name, routing, and go-to
sections will be deferred to later chapters.</p>
</div>
<div class="paragraph">
<p>§2.3.1 <strong>Replacement Material</strong> in the workspace can be replaced by other
material. Suppose the German sentence <em>Der Mann ist alt.</em> (The man is
old.) is represented in the workspace as</p>
</div>
<div class="listingblock">
<div class="content">
<pre>-DER + -MANN + -IST + -ALT +</pre>
</div>
</div>
<div class="paragraph">
<p>and, as part of a translation program, it is desired to replace the German
word -DER by the English word -THE. The rule is written as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* -DER = -THE *</pre>
</div>
</div>
<div class="paragraph">
<p>The left-half contains -DER, which causes the computer to search the
workspace in a left-to-right search for a constituent -DER. If such a
constituent is found, the rule proceeds, and the right-half expression
-THE is executed, causing replacement in the workspace of -DER by
-THE. But if such a constituent is not found because the workspace
does not contain -DER, the search is said to fail and control goes
immediately to the next rule, the rest of the rule not being executed.</p>
</div>
<div class="paragraph">
<p>§2.3.1.1 The left-half serves several functions Simultaneously. It serves to
refer to the particular data in the workspace that is to be manipulated; it
serves to specify a search of the workspace for a particular constituent (or
constituents); and it serves to affect the flow of control by whether the
search succeeds or fails. Left-half tests are the most usual tests in COMIT
for loop control, and left-half failure is the most common form of exit from
a loop for the reason that it automatically results when the Workspace no
longer contains material appropriate for further processing.</p>
</div>
<div class="paragraph">
<p>§2.3.1.2 Thus, if the workspace contained</p>
</div>
<div class="listingblock">
<div class="content">
<pre>A+A+A</pre>
</div>
</div>
<div class="paragraph">
<p>the following one-rule loop would apply three times before left-half rule
failure would cause control to go to the next rule.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* A = B /</pre>
</div>
</div>
<div class="paragraph">
<p>The first time through, the leftmost A would be found and replaced by a B. The
second and third A would be found and replaced on the second and third time
through, leaving the workspace with</p>
</div>
<div class="listingblock">
<div class="content">
<pre>B+B+B</pre>
</div>
</div>
<div class="paragraph">
<p>On the fourth time through, the left-half search would fail to find an
unreplaced A, causing control to go immediately to the next rule on
account of rule failure, instead of control continuing through the
right-half and go-to sections of the rule.</p>
</div>
<div class="paragraph">
<p>§2.3.2 <strong>Rearrangement</strong> Material in the workspace can be rearranged. Suppose that
the misspelled word <em>recieve</em> is represented in the workspace as</p>
</div>
<div class="listingblock">
<div class="content">
<pre>R+E+C+I+E+V+E</pre>
</div>
</div>
<div class="paragraph">
<p>and it is desired to correct this spelling. A possible rule is as
follows:</p>
</div>
<div class="paragraph">
<p>The numbers 2 and 1 in the right-half of the rule refer to the second
and first constituents mentioned in the left-half. The result is that
the I and E are interchanged in the workspace. A more general rule
that would mechanize part of the spelling rule <em>i before e except
after c</em> is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* C + I + E = 1 + 3 + 2 *</pre>
</div>
</div>
<div class="paragraph">
<p>§2.3.2.1 We have mentioned that one of the functions of the left-half of the
rule is to refer to data. The search mechanism by which this is accomplished is
as follows. Suppose the workspace contains</p>
</div>
<div class="listingblock">
<div class="content">
<pre>A + B + B + C + B + C + A</pre>
</div>
</div>
<div class="paragraph">
<p>And we have a rule:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* B + C = 2 + 1 *</pre>
</div>
</div>
<div class="paragraph">
<p>The search that is set up is for a constituent B in the workspace and
an immediately following G. Since the search is from left to right, it
will be satisfied only with the second B and the following C, that is
the third and fourth constituents from the left. When the search has
been satisfied, the constituents that have been found are marked
temporarily for easy reference in other parts of the rule by numbers
called relative constituent numbers.  These numbers are assigned in
numerical order from left to right to the constituents that have been
found. Thus after the left-half of the above rule has been executed,
the constituents found are marked as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>A + B + B + C + B + C + A
       [1] [2]</pre>
</div>
</div>
<div class="paragraph">
<p>§2.3.2.2 The right-half expression then merely directs the computer to replace
these workspace constituents by the constituents mentioned in the right-half
in the indicated order. <em>Constituents that have not been found by the left-half
search remain unchanged.</em> Thus our rule above would leave the workspace with
the B and C reversed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>A + B + C + B + B + C + A</pre>
</div>
</div>
<div class="paragraph">
<p>After the right-half has been executed, the left-half relative constituent
numbers disappear. They are replaced by right-half relative constituent numbers
for convenient reference in the routing. Then, when the execution of the rule
has been finished, all relative constituent numbers disappear.</p>
</div>
<div class="paragraph">
<p>§2.3.3 <strong>Insertion</strong> Material may be inserted at any point in the
workSpace. Suppose the workspace contains</p>
</div>
<div class="listingblock">
<div class="content">
<pre>ACE + KING + QUEEN + TEN</pre>
</div>
</div>
<div class="paragraph">
<p>and it is desired to insert JACK after QUEEN. The following rule will do it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* QUEEN = l + JACK *</pre>
</div>
</div>
<div class="paragraph">
<p>After the computer has executed the rule? the workspace will contain</p>
</div>
<div class="listingblock">
<div class="content">
<pre>ACE + KING + QUEEN + JACK + TEN</pre>
</div>
</div>
<div class="paragraph">
<p>There is no trouble in squeezing new constituents in between old ones.</p>
</div>
<div class="paragraph">
<p>§2.3.4 <strong>Deletion</strong> Material may be deleted from the workspace in two
ways. In the first way, everything that is mentioned in the left~half
is deleted by writing a zero in the right-half. As an example, suppose
that the word <em>colour</em> is represented in the workspace as</p>
</div>
<div class="listingblock">
<div class="content">
<pre>C + O + L + O + U + R</pre>
</div>
</div>
<div class="paragraph">
<p>and it is desired to Americanize the spelling by deleting the letter U. The
rule is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* U = 0 *</pre>
</div>
</div>
<div class="paragraph">
<p>§2.3.4.1 A rule of this type would not work properly in all cases. Suppose
the word <em>house</em> is misspelled <em>housue</em> and is represented in the
workspace as</p>
</div>
<div class="listingblock">
<div class="content">
<pre>H + O + U + S + U + E</pre>
</div>
</div>
<div class="paragraph">
<p>Since the search is from left to right, the above rule would delete the first
U and not the second one. After the execution of the rule, the workspace would
contain</p>
</div>
<div class="listingblock">
<div class="content">
<pre>H + O + S + U + E</pre>
</div>
</div>
<div class="paragraph">
<p>§2.3.4.2 This brings us to the second method of deletion: replace two
constituents by one of them (or three by two or one of them, etc.). We
have again in the workspace:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>H + O + U + S + U + E</pre>
</div>
</div>
<div class="paragraph">
<p>and we want to delete the U that follows the S. The rule is</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* S + U = 1 *</pre>
</div>
</div>
<div class="paragraph">
<p>In other words, if any operation is specified in the right-half, any
constituent that is mentioned in the left-half but not in the
right-half will be deleted.</p>
</div>
<div class="paragraph">
<p>§2.3.5 <strong>No Right-Half</strong> It is important to realize that if no operation
is specified by the right-half, the workspace remains unchanged. A
rule with no right-half might very well be used for a test. Thus the
rule</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* U =   A *</pre>
</div>
</div>
<div class="paragraph">
<p>should serve as a test that would direct control to A if the workspace contained
constituent U; otherwise the rule would fail and control would go to the
next rule.</p>
</div>
<div class="paragraph">
<p>§2.3.6 <strong>Duplication</strong> Material in the workspace may be
duplicated. Suppose that ED been added to an English verb by an
insertion rule, and, since the verb is it is necessary to double the
final consonant. One has in the workspace:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>P + L + A + N + E + D</pre>
</div>
</div>
<div class="paragraph">
<p>The following rule will do it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* N = 1 + 1 *</pre>
</div>
</div>
<div class="paragraph">
<p>The constituent found by the left-half can be copied and inserted in
the workspace as many times as necessary by merely repeating in the
right-half the ﬁgure representing the constituent.</p>
</div>
<div class="paragraph">
<p>§2.4 Summary</p>
</div>
<div class="paragraph">
<p>The following left-half and right-half notations have been introduced:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* A =          FOUND</pre>
</div>
</div>
<div class="paragraph">
<p>Test for A. Search in the workspace for an A, and if found, go to the rule
FOUND; otherwise fail and go to the next rule.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* A + B = FOUND</pre>
</div>
</div>
<div class="paragraph">
<p>Test for A + B . Search in the workspace for an A followed by a B, and if found,
go to the rule FOUND; otherwise fail and go to the next rule.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* A = B *</pre>
</div>
</div>
<div class="paragraph">
<p>Replacement. Search in the workSpace for an A, and if found, replace it by a
B and go to the next rule; otherwise fail and go to the next rule.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* A + B = 2 + 1 *</pre>
</div>
</div>
<div class="paragraph">
<p>Rearrangement. Search in the wogkspace for an A followed by a B, and if found,
replace them by the second followed by the first and go to the next rule;
otherwise fail and go to the next rule.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* A = 1 + B *</pre>
</div>
</div>
<div class="paragraph">
<p>Insertion. Search in the workspace for an A, and if found, replace it
by itself followad by a B and go to the next rule; otherwise fail and
go to the next rule.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* A = 0 *</pre>
</div>
</div>
<div class="paragraph">
<p>Deletion. Search in the workspace for an A, and if found, delete it and go to
the next rule; otherwise fail and go to the next rule.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* A + B = 2 *</pre>
</div>
</div>
<div class="paragraph">
<p>Deletion. Search in the workspace for an A followed by a B, and if
found, replace them by the second and go to the next rule; otherwise
fail and go to the next rule.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* A = 1 + 1 *</pre>
</div>
</div>
<div class="paragraph">
<p>Duplication. Search in the workspace for an A, and if found, replace
it by itself followed by itself and go to the next rule; otherwise
fail and go to the next rule.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A + B + C = 2 + D + 1 + F + 2 *</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A combination. Search in the workspace for an A followed by a B followed by a
C and if found, replace them in the workspace by the second followed by a D
followed by the first followed by an F followed by the second and then go to
the rule Q; otherwise fail and go to the next rule.</p>
</div>
<div class="paragraph">
<p>It is important to note that the only places in the preceding examples where
if space is <em>required</em> are just after the NAME section and just before the GO-TO
ction. Wherever else a space is shown, it is <em>optional</em>.</p>
</div>
<div class="paragraph">
<p>The reader should now be in a position to work through a few illustrative
problems.</p>
</div>
</div>
<div class="sect2">
<h3 id="_2_5_problems_for_chapter_2">2.5 Problems for Chapter 2</h3>
<div class="olist upperalpha">
<ol class="upperalpha">
<li>
<p><a id="question2a"></a> The workspace contains several letters. If two
adjacent constituents are O and R, insert a U between
them. <a href="#answer2a">(Answer)</a></p>
</li>
<li>
<p><a id="question2b"></a> Change every O + U + R to O + R. <a href="#answer2b">(Answer)</a></p>
</li>
<li>
<p><a id="question2c"></a> Delete every B in the workspace. <a href="#answer2c">(Answer)</a></p>
</li>
<li>
<p><a id="question2d"></a> Change every B to a C. <a href="#answer2d">(Answer)</a></p>
</li>
<li>
<p><a id="question2e"></a> Interchange the first X immediately followed by
a 8 With the B. <a href="#answer2e">(Answer)</a></p>
</li>
<li>
<p><a id="question2f"></a> Insert an X before the first B. <a href="#answer2f">(Answer)</a></p>
</li>
<li>
<p><a id="question2g"></a> The leftmost constituent in the workspace is an
X, and all the other constituents are B&#8217;s. Move the X to the rightmost
position. <a href="#answer2g">(Answer)</a></p>
</li>
<li>
<p><a id="question2h"></a> The workspace contains a number of
constituents. They are all A&#8217;s except for an X somewhere in the
middle. Change all the A&#8217;s that are to the left of the X to B&#8217;s. Leave
everything else unchanged. <a href="#answer2h">(Answer)</a></p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_flow_of_control_in_comit">THE FLOW OF CONTROL IN COMIT</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_3_1_the_comit_program">3.1 The COMIT Program</h3>
<div class="paragraph">
<p>(Editor&#8217;s note: the introductory material on card formats, COM, END,
and COMSET is obsolete and included here only for historical flavor.
COMIT Revived reads COMIT II programs from text files, does
not require COM or END lines, and does not interpret COMSET lines.)</p>
</div>
<div class="paragraph">
<p>§3.1.0.0 In this chapter we will discuss in detail how a COMIT program
is organized and how the flow of control is directed. Material to be
submitted to the computer, both program and data, is punched on cards
or typed in lines on an on-line typewriter. When a program is being
punched or typed, only the first 72 positions on the card are used to
carry program information. Since a punched card has 80 columns there
are 8 extra positions at the far right that may be left blank or may
be used for identification numbers. This section of the card is called
the identification field or ID field. Data cards, however, can have
data punched in all 80 card columns. The COMIT program can read the
whole card and send information from all 80 columns to the workspace.</p>
</div>
<div class="paragraph">
<p>§3.1.1 <strong>Title Card</strong> The first card of the COMIT program is a title
card, which must have COM in columns 8, 9, and 10 and may have any
punching in any of the other columns, usually program identification
information, such as the programmer&#8217;s name and the name of the
program. This information will later be automatically printed at the
top of the output so that it can readily be identified and separated
from the output of other programs. The title card signals to the
compiler that this is the beginning of a COMIT program. Then, when the
compiler program is run, the flow of control starts with the first
rule after the title card.</p>
</div>
<div class="paragraph">
<p>§3.1.2 <strong>END Card</strong> The last card of the program must be an END card, which is a
card with END anywhere in the first 72 card columns, the rest being blank. The
END card signals to the compiler that this is the end of the COMIT program. It
also serves to terminate the flow of control during the running of the program.
Input data may follow the END card or may be read separately from other input
devices.</p>
</div>
<div class="paragraph">
<p>§3.1.3 <strong>COMSET Cards</strong> After the title card there may be one or more COMSET cards.
These cards have various functions such as setting the limits on the length of
the run, changing the bell and margin settings for printed output, and setting
other options when the standard values provided are inappropriate for a partic
ular program. These COMSET cards all have a blank in column 1.</p>
</div>
<div class="paragraph">
<p>§3.1.4 <strong>Rules</strong> Between the COM card and the END card and after any
COMSET cards: the program itself is inserted. The rules making up the
COMIT program are executed one at a time by the computer. When a rule
is being executed we say that control is in that rule, and as the
rules are executed one after another we say that control passes
fromsone rule to another.</p>
</div>
<div class="paragraph">
<p>§3.1.4.1 A rule may extend onto more than one card if necessary. If a hyphen
(or a minus sign) is the last nonblank character before column 73 on a card,
the rule continues to the next card. Each rule must always start at
the beginning of a card with a nonblank character in column 1. Rules
are thus distinguished from COMSET cards, which have column 1 blank.</p>
</div>
<div class="paragraph">
<p>§3.1.5 <strong>Names</strong> The first and the last sections of the rule have to do only with
a specification of the flow of control and are required sections of all rules.
In the first section of the rule, the name section, a name or label can be
written so that control can be directed to that rule by name. The optional
center sections of the rule not only deal with the data but also have some
function in the flow of control in that they may contain tests and branches
The last section of a rule, the go-to section, is executed after all the
sections of the rule have been executed. If a name is written in the go-to
section, control will be directed to the named rule. Of course it would be
error if there were no rule by that name or if there were two or more rules
by that name.</p>
</div>
<div class="paragraph">
<p>§3.1.5.1 Names may be freely and arbitrarily invented. Programmers usually
names that serve to remind them of what each rule is intended to accomplish
Programs with mnemonic names of this sort tend to be easier to read. A name
may be up to 12 characters in length and may consist of letters and numbers.
Periods and hyphens (or minus signs) may appear in medial position, that is
not at the beginning or the end. Examples of legal names are START,
FIRST-RETURN, 27, READ, 25.3A. Rules may have names reflecting numbered
boxes in a flowchart, and this is a great convenience when a program
has been carefully flowcharted.</p>
</div>
</div>
<div class="sect2">
<h3 id="_3_2_methods_of_directing_the_flow_of_control">3.2 Methods of Directing the Flow of Control</h3>
<div class="paragraph">
<p>§3.2.1 Linear Flow The simplest way to arrange COMIT rules into a program or a
routine is to line them up one after another in a linear arrangement. After
each rule has been executed, control will go to the next rule.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>l ... = ... 12
12 ... = ... 13
13 ... = ... 2</pre>
</div>
</div>
<div class="paragraph">
<p>where rule names and go-to names are shown at the beginning and end of each
rule. The dots represent other sections of the rules.</p>
</div>
<div class="paragraph">
<p>§3.2.1.1 Since a linear flow of control is quite frequently used, COMIT allows
the abbreviation of replacing a go-to name by an asterisk, which means go to
the next rule below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>1 ... = ... *
12 ... = ... *
13 ... = ... *</pre>
</div>
</div>
<div class="paragraph">
<p>§3.2.1.2 If control is not directed to a rule by name, but only from
the pre- ceding rule, either by an * go-to or by rule failure in the
preceding rule, then there is no need for the rule to have a name and
We can use the additional abbreviation of writing an asterisk in
column 1 in place of the rule</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* ... = ... *
* ... = ... *
* ... = ... *</pre>
</div>
</div>
<div class="paragraph">
<p>Of course, it does no harm to name the rules, and sometimes there is a
mnemonic advantage in so doing.</p>
</div>
<div class="paragraph">
<p>§3.2.2 <strong>Tests and Loops</strong> In order to write a loop, We need only to write
a test that will terminate the 100p, arranging that, in the case of
one of the outcomes of the test, control is directed to the next rule
to be executed within the loop, while in the case of the other outcome
of the test, control is directed to some point outside of the loop.</p>
</div>
<div class="paragraph">
<p>§3.2.2.1 The simplest type of loop to write in COMIT is the one-rule loop.
The left-half search is used for the test. In case the search is successful,
control continues on in the rule where right-half and routing operations may
be specified. The go-to carries control back again to the same rule. But if
the left-half search is unsuccessful, rule failure carries control to the next
rule, which is outside the one-rule loop. An example of such a loop is</p>
</div>
<div class="listingblock">
<div class="content">
<pre>LOOP1 A = B LOOP1</pre>
</div>
</div>
<div class="paragraph">
<p>§3.2.2.2 Since one-rule loops are frequently written, a simpler notation is
provided in COMIT, namely, the solidus (or fraction bar), which means, when
written in the go-to section of a rule, to go back to the same rule. The rule
may then not need a name unless it is referred to by name in some other go-to.</p>
</div>
<div class="paragraph">
<p>Thus our one-rule loop could be written in either of the two following ways:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>LOOP1 A = B /</pre>
</div>
</div>
<div class="paragraph">
<p>or</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* A = B /</pre>
</div>
</div>
<div class="paragraph">
<p>§3.2.2.3 Loops frequently involve more than one rule. The simplest
case of this is similar to the one-rule loop in that the loop is
terminated by rule failure that sends control to the next rule. The
test must therefore be incorporated in the last rule, and the go-to of
this rule must send control back to the beginning of the loop.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>LOOP2 ... *
*  ...... *
*  test... LOOP2
NEXT ...</pre>
</div>
</div>
<div class="paragraph">
<p>In this example, the three rules beginning with LOOP2 will be executed over
and over until the result of the test is rule failure, sending control to the
rule NEXT, which is outside of the loop. Sometimes it is important that the
test be the first rule executed when control enters the loop. This may be the
case if it is necessary to prevent the loop from being executed even once in
case the test should initially fail. There are two ways of doing this. The
first is to direct control from the previously executed routine directly to
the test rule:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>   ...... TEST3
LOOP3 ... *
*  .....  *
TEST3 test... LOOP3

NEXT ...</pre>
</div>
</div>
<div class="paragraph">
<p>This scheme has the possible disadvantage that control may
inadvertently enter the first rule of the loop in case of rule failure
of the rule above. The other way overcomes this disadvantage by moving
the rule with the test from last position to first position. If exit
from the loop is still to take place on rule failure, an extra rule
must be inserted after the test to send control out of the loop. Also
the test rule must have a go-to that jumps the loop flow of control
over this exit rule. This is accomplished by the special go-to
abbreviation: two asterisks, which means skip a rule.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>   ...... *
TEST4 test...
*    NEXT
*  ...... *
*  ...... TEST4
NEXT  ...</pre>
</div>
</div>
<div class="paragraph">
<p>In the above example, it can be seen that the three rules of the loop are the
second, the fourth, and the fifth.</p>
</div>
<div class="paragraph">
<p>§3.2.2.4 Sometimes the exit from a loop depends on rule success rather than
rule failure, although this is less frequent than loop exit on rule failure.
There are several ways that such loops can be programmed, the simplest is to
put the test rule first.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>TEST5 test NEXT

* ...... *
* ...... TEST5
NEXT ...</pre>
</div>
</div>
<div class="paragraph">
<p>§3.2.2.5 It is worth noting that a test that depends on rule success for loop
exit can not be put last in a 100p, because the normal or nonexit outcome of
the test is rule failure, which sends control to the next rule, which must be
part of the loop. A disadvantage of depending on rule success for loop exit is
that program errors can more easily lead to infinite loops.</p>
</div>
<div class="paragraph">
<p>§3.2.2.6 Another use for tests is in an error check. It is frequent in
a COMIT program to include tests that normally would succeed unless
something were wrong with the program or with the data supplied to
it. Usually these tests involve rule failure, consequently the double
asterisk go-to can be used in the normal case to skip the flow of
control past an error exit. This error exit is a COMIT rule that sends
control to an error’program provided by the programmer to cope with
the eventuality. This rule might not have any center section because
it might not have to do any processing. This use of the double
asterisk go-to is shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* ...... *
* test.. **
*    ERROR-EXIT
* ...... *</pre>
</div>
</div>
<div class="paragraph">
<p>§3.2.2.7 The normal way of terminating a run is to direct the flow of
control to the END card. Since the END card does not have a rule name,
the only ways of ending a program are to direct control to the END
card by means of a rule failure or an asterisk go-to in the last rule,
or by means of a double asterisk go-to in either of the last two rules
before the END card.</p>
</div>
<div class="paragraph">
<p>§3.2.3 <strong>Branches</strong> A branching flow of control can be handled in COMIT by a rule
that is more complex than those we have been talking about -a rule that is made
up of a number of subrules. The first subrule of the rule looks just like the
rules we have been writing, except that its name section contains, in addition
to the rule name, a subrule name. The succeeding subrules of the rule start on
separate cards and have only their subrule names in the name section, with the
first column of the card containing a blank. Each subrule may have its own
right-half, routing, and go-to, but it isﬂonly the first subrule that has the
left-half for the entire rule. Rule failure and the asterisk go-to, of course,
send control to the next rule. An example of a rule with several subrules is
as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>BRANCH1 A + B = 2 + 1 /
2             = 0     *
3                     **
4             = D     NEXT</pre>
</div>
</div>
<div class="paragraph">
<p>In this rule, BRANCH is the rule name and the numbers are subrule
names. When the rule is executed, first the left-half search takes
place. If it is successful, the right-half and go-to of one of the
subrules is executed. The choice of subrule is determined by the
dispatcher in a manner that will be explained in a later chapter. One
of the possibilities is that the subrule to be executed will be chosen
at random, a convenient feature for certain interesting types of
programs.</p>
</div>
<div class="paragraph">
<p>§3.2.4 Subroutines It is very easy to write closed subroutines and to call them
in COMTT, and there is a built-in pushdown that automatically takes care of
storing and obtaining the correct return point. Suppose we have a three-rule
subroutine called B. It might be written as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>B ...... *
* ...... *
* ...... /</pre>
</div>
</div>
<div class="paragraph">
<p>It is to be noted that a + is written in the go-to of the last rule of
the subroutine to be executed. This means that the flow of control
should be returned to the proper place in the calling program
according to the current contents of the built-in pushdown.</p>
</div>
<div class="paragraph">
<p>§3.2.4.1 In order to call a subroutine, one simply writes the name of
the subroutine in a go-to, then, after a plus sign, the name of the
return point. Thus the go-to expression SUB+RET1 means go to the
subroutine starting at rule SUB, and, on exit, return to the rule
named RETl. If it is desired to call the above subroutine B from
several points in the program //as was illustrated in figure 7,
section 1.2.6.1, the following rule names and go-to names would be
used:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>A ...... B+C
C ...
    .
    .
    .
L ...... B+M
M ...
    .
    .
    .
X ...... B+Y
Y ...</pre>
</div>
</div>
<div class="paragraph">
<p>§3.2.4.2 The scheme operates as follows: when the subroutine is called, the
name of the return point is automatically saved on a pushdown. Then, if the
called routine calls another before returning, the second return point is
stored on the same pushdown. Whenever a plus go-to is executed, the name of
the proper return point is obtained from the next item on the pushdown, and
this item is deleted. Control then returns to the proper point in the calling
program or routine.</p>
</div>
<div class="paragraph">
<p>§3.2.4.3 As an example of the use of a rule with subrules and of the
go-to, we will shortly exhibit a routine called SUB-Q that will change
a Q in the workspace to a simple English sentence, selected at random,
and return control to a rule called PRINT, which would print out the
sentence.</p>
</div>
<div class="paragraph">
<p>§3.2.4.4 There is a very deep connection between the organization of
subrou- tines and subroutine calls by means of a pushdown and the
phrase-structure organization of words and phrases in the grammar of a
language like English.  This is shown in figure 2, which illustrates
how the A+B type go-to can be used to represent the two constituents
of a phrase and how a rule with subrules can be used to provide
alternative words or constructions.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/phrase1.png" alt="phrase1">
</div>
</div>
<div class="paragraph">
<p>Figure 2. An organization of subroutines paralleling the
phrase-structure organization of some simple English sentences. The
boxes contain the names of the program rules. The brackets indicate
alternative choices using the random-choice feature of the rule with
subrules.</p>
</div>
<div class="paragraph">
<p>The routine is given next. It is assumed that the workspace contains a
Q when the routine is entered. On exit to the rule PRINT, the
workspace will contain a sentence that has been selected at random by
the routine from the sentences described by the grammar of figure 19.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SUB-Q      *+PRINT
SENTENCE   Q = 1 + 1 SUBJECT+PREDICATE
SUBJECT A   Q = -JOHN +
        B     = -BlLL +
        C     = -TOM  +
        D     = -HE   +
PREDICATE I      INTRANSITIVE
          T      TRANSlTlVE
INTRANSITIVE 1 Q = -LAUGHS +
             2   = -WORKS  +
             3   = -TALKS  +
TRANSITIVE Q = 1 + 1 VERB-T+OBJECT
VERB-T 1 Q = -SEES   +
       2     -HEARS  +
       3     -KNOWS  +
       4     -LIKES  +
       5     -HATES  +
OBJECT 1 Q = -MARY   +
       2     -JANE   +
       3     -SUE    +
       4     -HER    +</pre>
</div>
</div>
<div class="paragraph">
<p>§3.2.4.5 The last type of go-to that will be described in this chapter
is one similar to the A+B type used for a subroutine call, but written
with two plus signs instead of one. This go-to expression is similar
in operation to the one with one plus except that the name of the
return point is placed one down on the pushdown so that control will
return to this point only after it has re- turned to the point named
at the head of the pushdown. It turns out that this behavior is just
what is needed to produce a verb like "call up" in two parts with the
object between them as in "call her up." This is illustrated in figure
3, which gives some additions to the program of figure 19 so that it
includes verbs of this type.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/phrase1.png" alt="phrase1">
</div>
</div>
<div class="paragraph">
<p>Figure 3. A portion of figure 19 modified to take care of
discontinuous constructions such as CALLS&#8230;&#8203;UP as in CALLS MARY
UP. The dotted line represents the fact that the return point
ADV-D has been placed one down on the pushdown, below OBJECT}by a
go-to of the A++B type.</p>
</div>
<div class="paragraph">
<p>§3.2.4.6 The modified rules and additional rules required to incorporate thi
material into the previous program are given below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>VERB-T 1 Q = -SEES   +
       2     -HEARS  +
       3     -KNOWS  +
       4     -LIKES  +
       5     -HATES  +
       6             DISC-V
DISC-V   Q   = 1 + 1   VERB-D++ADV-D
VERB-D  1  Q  = -CALLS    +
        2     = -BRINGS   +
	3     = -TAKES    +
ADV-D  1 Q    = -UP       +
       2      = -DOWN     +
       3      = -OVER     +</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_3_3_0_summary">3.3.0 Summary</h3>
<div class="paragraph">
<p>§3.3.0.0 The following is a summary of the flow-of-control conventions in
COMIT. A COMIT program starts with a title card having COM in columns 8, 9,
and 10. It ends with an END card. Following the COM card there may be COMSET
cards to set various options. A COMSET card has a blank in column 1.</p>
</div>
<div class="paragraph">
<p>§3.3.0.1 COMIT rules follow the COM card and any COMSET cards and precede the
END card. All these cards may have program information punched in the first
72 columns. The remaining 8 card columns are free for optional card
identification numbers. Data cards to be read by the COMIT program may follow
the END card; all 80 card columns are read.</p>
</div>
<div class="paragraph">
<p>§3.3.0.2 A COMIT rule starts with a name section that may contain the name of
the rule or an asterisk in case the rule does not need a name. In either case
punchng is started in column 1. A name may be up to 12 characters long and
consist of letters, numbers, and periods and hyphens in medial position.
The name section is separated from the center sections of the rule by one or
blanks (spaces).</p>
</div>
<div class="paragraph">
<p>§3.3.0.3 In a rule with several subrules, the first subrule has the rule name
starting in column 1, and succeeding subrules have one or more blanks starting
in column 1. Next, each subrule has a subrule name. In the case of the first
subrule, this is separated from the rule name by one or more blanks. The first
subrule has the left-half for the rule, but each subrule may have its own
left-half, routing, and go-to.</p>
</div>
<div class="paragraph">
<p>§3.3.0.4 The go-to section of the COMIT rule is the last section in the rule
and is separated from the center sections by one or more Spaces. No spaces may
appear in the string of characters that make up the go-to. The following go-to
expressions have been introduced:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">NAME</dt>
<dd>
<p>means go to the rule named NAME.</p>
</dd>
<dt class="hdlist1">*</dt>
<dd>
<p>means go to the next rule</p>
</dd>
<dt class="hdlist1">**</dt>
<dd>
<p>means skip a rule</p>
</dd>
<dt class="hdlist1">NAME1+NAME2</dt>
<dd>
<p>means go to the rule NAMEl and store NAME2 on the pushdown.</p>
</dd>
<dt class="hdlist1">NAME1++NAME2</dt>
<dd>
<p>means go to the rule NAMEl and store NAME2 on the
pushdown just beyond the item that is next.</p>
</dd>
<dt class="hdlist1">+</dt>
<dd>
<p>means go to the rule named in the next item on the pushdown and
delete that item from the pushdown.</p>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_some_powerful_notations">SOME POWERFUL NOTATIONS</h2>
<div class="sectionbody">
<div class="paragraph">
<p>§4.0.0.0 In chapter 2, the basic operations of replacement,
rearrangement, insertion, deletion, and duplication were introduced,
as well as a basic description of the left-half search and test
operations. With just these notations, however, the COMIT programmer
would be very restricted in expression.  The greatest restriction is
the fact that so far we cannot refer in the left- half to a workspace
constituent unless we know exactly what it is. This chapter begins by
introducing some left-half notations for reference that correspond
roughly to the following English expressions: something, nothing,
three things, anything but, everything up to a point, the same as. It
then proceeds to the nine most important routing instructions, namely,
those used for moving data between the workspace and the shelves and
expanding and compressing constituent symbols.</p>
</div>
<div class="sect2">
<h3 id="_4_1_some_left_half_notations">4.1 Some Left-Half Notations</h3>
<div class="paragraph">
<p>§4.1.1 <strong>Finding an Unknown Constituent</strong> It is sometimes necessary to
carry out an operation like replacement, rearrangement, deletion, or
duplication on a constitutent when it is not known what the
constituent is but only where it is. We need a notation like the x in
algebra for use in the left-half. Suppose, as in the example under
Duplication in section 2.3.6, that ED has been added to one of the
group of English verbs that double the final consonant. It is desired
to write a rule that will apply no matter what the final consonant is.</p>
</div>
<div class="paragraph">
<p>The workspace might contain any of the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>P+E+R+M+I+T+E+D
P+L+A+N+E+D
B+A+G+E+D
S+H+I+P+E+D</pre>
</div>
</div>
<div class="paragraph">
<p>The unknown consonant cannot be represented by X since X written in
the left-half means find the letter X. The Special abbreviation $1,
read <em>dollar one</em>, is used, which means find any single
constituent. The rule to double any final consonant before ED can now
be written</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $1 + E + D = 1 + 1 + 2 + 3 *</pre>
</div>
</div>
<div class="paragraph">
<p>§4.1.1.1 The abbreviation $1 can also be used to locate the first
constituent§ in the workspace. Suppose the workSpace contains a number
of constituents resulting from some subroutine, and it is desired to
insert the word RESULT before the first constituent in the
workspace. The following rule will do it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $1 = RESULT + 1 *</pre>
</div>
</div>
<div class="paragraph">
<p>The $1 in this rule will find the first constituent in the
workspace. Since no other left-half match criteria have been
mentioned, it will find the first constituent it comes to in the
left-to-right search.</p>
</div>
<div class="paragraph">
<p>§4.1.1.2 Another important use for $1 is to test for an empty workspace. The
following rule:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $1 = NOT-EMPTY</pre>
</div>
</div>
<div class="paragraph">
<p>will fail if the workspace is empty but will not fail if the workspace contains
even one constituent.</p>
</div>
<div class="paragraph">
<p>§4.1.2 <strong>Finding Anything But</strong> Related to $1 is a notation that allows one
to refer to any constituent that is not the one specified. This is
done by $-SYM read dollar not symbol, where SYMBOL represents any of
the types of workspa constituent symbols that have been introduced so
far, that is, one or more compressed characters, as explained in
section 2.1.0.0. As an example, take problem H of section 2.5, in
which the workspace contained an X somewhere in the middle of a string
of A&#8217;s, and it was desired to change all the A&#8217;s to
left of the X to B'5. It can now be done in a one-rule loop:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* A + $-A = B + 2 /</pre>
</div>
</div>
<div class="paragraph">
<p>The $-A will first find the X, then on succeeding times through it
will find a B. When all the A&#8217;s to the left of the X have been changed
to 8'5, the rule will fail because there will no longer be an A in the
workspace that is followed by a constituent that is not an A.</p>
</div>
<div class="paragraph">
<p>§4.1.3 Finding n Constituents The left-half notation $2 (dollar two)
will find any two consecutive constituents, $3 will find any three
consecutive constitu- ents, and so on. A group of n workspace
constituents found by the single left- half constituent $n can be
replaced, rearranged, deleted, duplicated, and so forth, as a unit. As
an example, the following rule will exchange the three constituents
preceding the constituent POST with the two constituents following the
constituent POST:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $3 + POST + $2 = 3 + 2 + 1 *</pre>
</div>
</div>
<div class="paragraph">
<p>§4.1.3.1 When an expression such as $3 is used to refer to several constituents
at a time, the several constituents are grouped together and given a single
relative constituent number. As an example, suppose the workspace
contains</p>
</div>
<div class="listingblock">
<div class="content">
<pre>AB + CDE + F + CH + IJK + L + MN</pre>
</div>
</div>
<div class="paragraph">
<p>and the left-half of the following rule is applied:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* F + $3 = 1 *</pre>
</div>
</div>
<div class="paragraph">
<p>After the left-half search has Succeeded, the constituents found are marked
with left-half relative constituent numbers as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>AB + CDE + F + GH + IJK + L + MN
         [_1_] [2__________]</pre>
</div>
</div>
<div class="paragraph">
<p>The right-half, of course, will delete the group of three constituents.</p>
</div>
<div class="paragraph">
<p>§4.1.4 <strong>Null Constituents</strong> It is also possible to set up a left-half
relative constituent number that is not associated with any workspace
constituent. This is done with the left-half notation $¢ (dollar
zero), which assigns a relative constituent number to a null
constituent, that is, a place in the workspace which does not contain
any workspace constituents.</p>
</div>
<div class="paragraph">
<p>§4.1.4.1 Although there are important reasons for wanting to refer in later
sections of the rule to such null constituents by mentioning their relative
constituent numbers, the most frequent use of $0 in COMIT programming is to
specify in a left-half search either the left end of the workspace or the right
end. If $0 is written at the left end of the left-half, or if it is the only
notation in the left-half, it refers to the left end of the workspace; if it is
written at the right end of the leftshalf, it refers to the right end of the
workspace. Thus the rule:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $0 + A = B *</pre>
</div>
</div>
<div class="paragraph">
<p>will fail if the workspace does not have an A at the left end. This use of $0
is very important, because otherwise it would be necessary to explicitly mark
the left end by introducing a marker constituent in a separate rule in some
such fashion as the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $1 = X + 1 *
* X + A = B *</pre>
</div>
</div>
<div class="paragraph">
<p>There is a further advantage of using the $0. When the workspace does
not have an A at the left end, the rule with $¢ will fail immediately;
otherwise, the whole workspace must be searched for an X followed by
an A. This can be a considerable saving in computer time if the rule
is frequently executed and the workspace contains many constituents.</p>
</div>
<div class="paragraph">
<p>§4.1.4.2 The following rule gives an example of the use of $Q to mark the right
end of the workspace. If the last constituent in the workspace is an A, it will
be changed to a B.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* A + $0 = B *</pre>
</div>
</div>
<div class="paragraph">
<p>§4.1.4.3 It is important to understand how the $0 sets up a null constituent
and assigns a relative constituent number to it. Suppose the workspace contains</p>
</div>
<div class="listingblock">
<div class="content">
<pre>A + B + C + D</pre>
</div>
</div>
<div class="paragraph">
<p>and the left-half of the following rule is applied:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* B + $0 + C = rest of rule</pre>
</div>
</div>
<div class="paragraph">
<p>The left-half search will only succeed if the workspace contains a constituent
B followed by a constituent C with no constituent between them. This is the
case here. After the left-half search has succeeded, the constituents are
marked with relative constituent numbers as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>A + B +   + C + D
   [1] [2] [3]</pre>
</div>
</div>
<div class="paragraph">
<p>It can be seen that a null constituent has been set up in the
workspace and given the relative constituent number 2. This provides a
place in the workspace into which data can be inserted from the input
or from a shelf under the direction of a routing instruction. Any null
constituents left after the rule has been executed disappear along
with the relative constituent numbers.</p>
</div>
<div class="paragraph">
<p>§4.1.4.4 A $0 can also be used in the right-half for this purpose. The
following left-half and right-half would give the same results as the
above left-half, except that the relative constituent numbers set up
would be right-half relative constituent numbers.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* B + C = 1 + $0 + 2 rest of rule</pre>
</div>
</div>
<div class="paragraph">
<p>§4.1.4.5 Suppose it is desired to find out whether the workspace has exactly 23
constituents in it. The following rule makes such a test:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $0 + $23 + $0 = YES</pre>
</div>
</div>
<div class="paragraph">
<p>§4.1.4.6 Of course, if the leftmost $0 finds the left end of the workspace, and
the rightmost $0 finds the right end of the workspace, the following rule will
be a test that will succeed only if the workspace is empty:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $0 + $0 = EMPTY</pre>
</div>
</div>
<div class="paragraph">
<p>§4.1.4.7 It should be noted that if the $Q is the only notation in the
left-half, it will find the left end of the workspace even if the
workspace is empty. It may thus be used to set up a null constituent
for bringing data into an empty workspace.</p>
</div>
<div class="paragraph">
<p>§4.1.4.8 The use of $0 can be summarized as follows:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>A $0 alone in the left-half or at the left end of the left-half means find
the left end of the workspace.</p>
</li>
<li>
<p>A $0 at the right end of the left-half means find the right end of the
workspace.</p>
</li>
<li>
<p>A left-half consisting of $0 + $0 therefore means find both ends of the
workspace with nothing between, that is, it will find only an empty workspace.</p>
</li>
<li>
<p>A $0 in the left-half that is neither at the left end nor at the right end
of the left-half has no effect on whether the left-half search succeeds or
fails.</p>
</li>
<li>
<p>Whenever a left-half search succeeds, a null constituent is inserted in the
workspace for each $0 in the left-half and provided with the appropriate
left-half relative constituent number.</p>
</li>
<li>
<p>In the right-half, if $0 appears anywhere, it inserts a null constituent
into the workspace and provides it with the appropriate right-half relative
constituent number. (See section 2.3.2.2.)</p>
</li>
<li>
<p>When the execution of the rule is finished, all relative
constituent numbers disappear, and any remaining null constituents in
the workspace are deleted.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>§4.1.5 <strong>Finding an Unknown Number of Constituents</strong> Sometimes even the
number of constituents it is desired to find is unknown. For this we
use the indefinite dollar sign $ (dollar) without a number. The
left-half expression $ will find any number of constituents (including
none) between specified boundary constituents or the ends of the
workspace. It is the only other left-half notation that can refer to
an empty workspace or can set up a null constituent.</p>
</div>
<div class="paragraph">
<p>§4.1.5.1 Suppose it is desired to delete an unknown expression between commas.
The workspace might contain</p>
</div>
<div class="listingblock">
<div class="content">
<pre>-BILL + , + -THEY + -SAY + , + -IS + -RETIRED</pre>
</div>
</div>
<div class="paragraph">
<p>The following rule:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* , + $ + , = 0 *</pre>
</div>
</div>
<div class="paragraph">
<p>will delete the commas and everything between them, no matter how many
constituents there are. The Workspace will be left with</p>
</div>
<div class="listingblock">
<div class="content">
<pre>-BILL + -IS + -RETIRED</pre>
</div>
</div>
<div class="paragraph">
<p>§4.1.5.2 As another example of the use of the indefinite dollar sign $,
suppose we have a filing system set up in the workspace, and it is
desired to file the first constituent in the workspace under
CLOTHING. The following rule will do it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $1 + $ + CLOTHING = 2 + 3 + 1 *</pre>
</div>
</div>
<div class="paragraph">
<p>The first constituent is moved to its new place immediately to the right of
CLOTHING no matter how many intervening constituents there are.</p>
</div>
<div class="paragraph">
<p>§4.1.5.3 Or, if one had a filing system with headings and subheadings, the
following rule would find the first constituent filed under the PROTECTIVE
that is under SHOES and move it into the first position in the workspace.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $ + SHOES + $ + PROTECTIVE + $1 = 5 + 1 + 2 + 3 + 4 *</pre>
</div>
</div>
<div class="paragraph">
<p>The first $ finds everything between the left end of the workspace and
SHOES; thus it serves to mark the left end of the workspace for the
desired rearrangement.</p>
</div>
<div class="paragraph">
<p>4.l.5.4 The indefinite dollar sign also makes a problem like G in section 2.5
a lot easier. It is desired to move thealeftmost constituent to the right end
of the workspace. The following rule:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $1 + $ = 2 + 1 *</pre>
</div>
</div>
<div class="paragraph">
<p>will do it without the necessity for writing a loop. The $1 finds the leftmost
constituent and the $ finds all the rest. And we don&#8217;t have to know that the
first constituent is an X and all the rest are B&#8217;s as in the problem.</p>
</div>
<div class="paragraph">
<p>§4.1.5.5 The indefinite dollar sign $, if written alone in the left-half, will
find everything in the workspace. The following rule:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $ = START + Q *</pre>
</div>
</div>
<div class="paragraph">
<p>will find everything in the workspace and replace it with the constituents</p>
</div>
<div class="listingblock">
<div class="content">
<pre>START + Q</pre>
</div>
</div>
<div class="paragraph">
<p>§4.1.5.6 As another example, the following rule:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $ = 0 *</pre>
</div>
</div>
<div class="paragraph">
<p>will delete everything in the workspace. Compare this with the loop
that is necessary when using only the facilities of chapter 2 for
problem 3 of that chapter (section 2.5) and the necessity there of
knowing what is in the workspace before it can be deleted.</p>
</div>
<div class="paragraph">
<p>§4.1.5.7 The notation $ written alone in the left-half is also capable
of referring to an empty workspace. This is important because a COMIT
program always starts off with an empty workspace when it is run. The
following rule will insert A + B into an empty workspace, or if the
workspace has something in it, it will all be replaced by A + B.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $ = A + B *</pre>
</div>
</div>
<div class="paragraph">
<p>When the workspace is empty, the $ sets up a null constituent and assigns it a
left-half relative constituent number 1. This is then replaced by the A + B.
The $ written alone in the left-half and the $Q written alone in the left-half
will both set up a null constituent when the workspace is empty. They differ
when the workspace is not empty. The $ finds everything in the workspace; the
$0 finds the left end.</p>
</div>
<div class="paragraph">
<p>§4.1.5.8 The way in which a left-half search involving an indefinite dollar
sign $ works is as follows: There are three cases: the $ at the left end of
the left-half, the $ in medial position, and the $ at the right end of the
left-half. In each case the $ will refer to all the constituents from the last
definite position defined in the search to the next definite position. Thus in
the rule:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $ + A + B + $ + C + $ = 2 + 4 *</pre>
</div>
</div>
<div class="paragraph">
<p>the first $ will find all constituents from the left end of the
workspace, which is the first definite position, up to the first A
followed by a B, which define the second definite position. If the A
and B are the first and second constituents in the workspace, the $
will find a null constituent. The second $ will find everything
between the A + B that has just been found and the next C, which is
the next definite position. The third $ will find everything between
the C that has been found and the right end of the workspace, which is
the last definite position. The right half will then delete everything except
the A and the constituents between the B and the C.</p>
</div>
<div class="paragraph">
<p>§4.1.5.9 Thus, the left-half of the above rule will set up, in the workspace
indicated below, three null constituents and constituent numbers as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>     A + B +     C
[1] [2] [3] [4] [5] [6]</pre>
</div>
</div>
<div class="paragraph">
<p>But if the workspace Were as follows, it would not have to set up any null
constituents:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>A + A + A + B + B + B + B + C + C
[1___] [2] [3] [4________] [5] [6]</pre>
</div>
</div>
<div class="paragraph">
<p>§4.1.6 <strong>Finding Matching Constituents</strong> One of the most powerful
left-half notations is a method of finding a constituent in the
workspace that matches one already found. This can be done without
knowing specifically what the constituents are. The constituent
already found can act as if it had been written in
the left-half. Thus if the workspace contains</p>
</div>
<div class="listingblock">
<div class="content">
<pre>A + B + C + A + D</pre>
</div>
</div>
<div class="paragraph">
<p>and the following rule is executed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $1 + $ + 1 = 1 + 2 *</pre>
</div>
</div>
<div class="paragraph">
<p>the result of the left-half search will be</p>
</div>
<div class="listingblock">
<div class="content">
<pre> A + B + C + A + D
[1] [2____] [3]</pre>
</div>
</div>
<div class="paragraph">
<p>The left-half number 1 finds the second A just as if the workspace A found by
the $1 had been written in the rule as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $1 + $ + A = 1 + 2 *</pre>
</div>
</div>
<div class="paragraph">
<p>It is worth noting that had the workspace contained</p>
</div>
<div class="listingblock">
<div class="content">
<pre>A + B + C + C + B + C + C</pre>
</div>
</div>
<div class="paragraph">
<p>the rule</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $1 + $ + 1 = 1 + 2 *</pre>
</div>
</div>
<div class="paragraph">
<p>would have failed in spite of there being two B&#8217;s. This is because the
$1 finds the A, and whenever an expression to the left of a $ matches
the workspace somewhere, it defines a definite position and will never
be moved. Note also that a left-half number n can refer only to a
single constituent in the workspace found by a left-half constituent
such as $1, and not by $ or $n, where n is greater than 1.</p>
</div>
<div class="paragraph">
<p>§4.1.6.1 The importance of the left-half number notation is not only
that one can find items in the workspace that are the same, but also
that one can effectively plug items from the workspace into a rule
where they can specify the search. This is one of the ways in which
the data can control a COMIT program without the danger of error
inherent in executing data.</p>
</div>
<div class="paragraph">
<p>§4.1.6.2 As a simple example, take the problem of algebraic factoring, where
it would be desired to convert AB+AC to A(B+C). As will be explained in detail
in a later chapter, + , ( , and ) are represented in the workspace by the
double characters *+ , *( , and *) . The rule for factoring culd then be
written as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $1 +$1 + *+ +1 + $1 = 1 + *( + 2 + 3 + 5 + *) *</pre>
</div>
</div>
<div class="paragraph">
<p>§4.1.6.3 So far in this chapter, we have introduced six important left-half
notations: $1, $-SYMBOL, $n, $¢, $, and n. They will be summarized at the end
of the chapter.</p>
</div>
</div>
<div class="sect2">
<h3 id="_4_2_the_routing">4.2 The Routing</h3>
<div class="paragraph">
<p>§4.2.0.0 Up to this point, we have covered basic features of the simple COMIT
rule, and how COMIT rules are organized into routines and programs. With this
apparatus, a wide diversity of tasks can already be programmed. What remains is
to take up some additional features that make it much easier to write certain
useful types of routines and make possible more efficient programs.</p>
</div>
<div class="paragraph">
<p>§4.2.1 <strong>Expanding and Compressing</strong> It is possible to change the grouping
of characters in constituents by means of a routing expression. For
example, if the workspace contains</p>
</div>
<div class="listingblock">
<div class="content">
<pre>-THE + -MAN</pre>
</div>
</div>
<div class="paragraph">
<p>it is possible to expand it so that each character becomes a separate
constituent.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>- + T + H +E + - + M + A + N</pre>
</div>
</div>
<div class="paragraph">
<p>The rule for this is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $1 + $1 = // *E1 2 *</pre>
</div>
</div>
<div class="paragraph">
<p>where the numbers after the E refer to the left-half or right-half relative
constituent numbers of the workspace expression or expressions to be expanded.
The abbreviation in the routing section says to expand the first and second
constituents. But note that double characters such as *+ and *( remain double
and are not expanded into two constituents.</p>
</div>
<div class="paragraph">
<p>§4.2.1.1 The resulting eight constituents can be compressed again into the
original two by the following rule:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>*  $4 + $ =     //*Kl, *K2 *</pre>
</div>
</div>
<div class="paragraph">
<p>where the number after each K refers to a group of constituents to be
compressed.</p>
</div>
<div class="paragraph">
<p>§4.2.1.2 Relative constituent numbers referred to with each *E and *K
must be consecutive numbers. They may be left-half or right-half
relative constituent numbers, whichever are current in the
workspace. The string of constituents formed by expanding with *E is
assigned, as a relative constituent number, the first of the
consecutive numbers written after the *E. Null constituents are
introduced into the workspace corresponding to the other
numbers. Similarly, the constituent formed by compressing with a *K is
assigned, as a relative constituent number, the first of the
consecutive numbers written after the *K, and null constituents are
introduced into the workspace corresponding to the others.</p>
</div>
<div class="paragraph">
<p>54.2.1.3 In either case, any subscripts (see next chapter) that any of
the expanded or compressed constitutents may have had will be lost.</p>
</div>
<div class="paragraph">
<p>§4.2.2 <strong>The Reduction of Search Time</strong> A computer operates rapidly, but
not instantaneously. If a program can be made to run ten times as fast
or even twice as fast, there may be a significant saving in running
time on the computer.</p>
</div>
<div class="paragraph">
<p>§4.2.2.1 In section 2.5, problem D asked to change every B to a C. The answer
given was</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* B = C /</pre>
</div>
</div>
<div class="paragraph">
<p>The running time of this routine is very sensitive to the amount of
material in the workspace. Suppose the workspace contains nothing but
B&#8217;s. Then if the routine operates with a workspace having 10 times as
many constituents, it will take approximately 100 times as long for
the routine to run. This is because, not only will the rule be
executed 10 times as often, but also the average search will be about
10 times as long, since the time of search is roughly proportional to
the amount of material searched over.</p>
</div>
<div class="paragraph">
<p>§4.2.2.2 COMIT handles this situation by making it possible to remove material
from the workspace when it is no longer needed for search purposes and to store
it on a shelf where it is out of the way but can be found in a hurry when it is
needed again. There is another reason why it is good practice to keep data that
is currently not being worked onaout of the workspace. Left-half failure is a
frequent means of exit from a loop. If excess material is being kept in the
workspace, the left-half may find some of this material by mistake, causing an
error in the loop-exit test.</p>
</div>
<div class="paragraph">
<p>§4.2.3 <strong>Shelving</strong> The procedure used to remove material from the
workspace to a shelf is shown in the following routine, which replaces
every B by a C. It will run much faster than the above routine if
there are more than a few constituents in the workspace.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $ + B = 1 + C // *Q23 1 2 /
* $0 =      // *A23 1 *</pre>
</div>
</div>
<div class="paragraph">
<p>In the first rule of this routine, the left-half finds everything up
to and including the first B. The right-half changes the B to a C. The
instruction *Q23 1 2 in the routing section of the rule serves to
queue onto the right end of shelf 23 the workspace expressions having
right-half relative constituent numbers 1 and 2. Thus it removes from
the workspace everything up to and including this C and moves them
onto the right end of shelf 23, keeping them in their original
workspace order and not disturbing anything that may already be on the
shelf. When the rule is executed again, this material that has already
been searched over is no longer in the workspace and will not be
searched over again. After all the B&#8217;s have been changed to C&#8217;s, the
rule fails and the next rule brings all from shelf 23 back to the
beginning of the workspace again. The whole routine is fast because
the workspace is only searched once and the shelving operations are
very fast.</p>
</div>
<div class="paragraph">
<p>§4.2.3.1 For a more complex example, suppose that shelf 5 contains</p>
</div>
<div class="listingblock">
<div class="content">
<pre>X + Y + Z</pre>
</div>
</div>
<div class="paragraph">
<p>and the following rule is executed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $2 + W + $3 = // *QS 3 1 *</pre>
</div>
</div>
<div class="paragraph">
<p>If the workspace is as follows, the left-half will set up relative constituent
numbers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>A + B + C + W + D + E + F + G
  [1_____] [2] [3________]</pre>
</div>
</div>
<div class="paragraph">
<p>Then, when the shelving instruction is executed, first the constituents with
relative constituent number 3 are moved as a unit to the right end of the shelf,
then the constituents with the relative constituent number 1. The workspace is
left with null constituents as shown:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>A +   + W +   + G
   [1] [2] [3]</pre>
</div>
</div>
<div class="paragraph">
<p>and the shelf is left with</p>
</div>
<div class="listingblock">
<div class="content">
<pre>X+Y+Z+D+E+F+B+C</pre>
</div>
</div>
<div class="paragraph">
<p>§4.2.3.2 The two shelf instructions that send material from the workspace to a
shelf operate according to the following summary:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>*Q5 1 2
 ││ ─┬─
 ││  │
 ││  └────── 1 and 2 refer to constituents by their right-half
 ││          relative constituent numbers.
 ││
 │└───────── a shelf number in the range1 through 127.
 │
*Q means queue onto right end of shelf.
*S means store onto left end of shelf.</pre>
</div>
</div>
<div class="paragraph">
<p>§4.2.3.3 The two shelf instructions that send material from shelf to workspace
follow the same pattern except that only one relative constituent number is
mentioned to designate the workspace expression to be replaced by data from
the shelf:</p>
</div>
<div class="paragraph">
<p>*A means take all from the shelf.</p>
</div>
<div class="paragraph">
<p>*N means take the next constituent from the left end of the shelf.</p>
</div>
<div class="paragraph">
<p>§4.2.3.4 It is worth noting that the routing instructions refer to
workspace constituents by right-half relative constituent numbers that
replace the left- half numbers after the right-half has been
executed. If there is no right-half, the right-half relative
constituent numbers are the same as the left-half ones.</p>
</div>
<div class="paragraph">
<p>§4.2.3.5 When material is brought off a shelf into the workspace, it
replaces whatever material in the workspace is marked by the relative
constituent number mentioned in the shelving instruction. When
material is removed from the workspace by a shelving instruction, a
null constituent is left. It is possible to bring material off a shelf
into a null constituent, which thereby is no longer null if there was
anything on the shelf. The expression $¢ may be used in the right-half
for the purpose of setting up right-half null constituents for
receiving shelf material; $0 is the only one of the $ type expressions
introduced in this chapter that can be used in the right-half.</p>
</div>
<div class="paragraph">
<p>§4.2.3.6 A routing section of a rule may contain any number of instructions
chosen from the group: *E, *K, *Q, *S, *A, *N. When there are more than one,
they are executed in left-to-right sequence, each operating on the contents of
the workspace and shelves as left after execution of the previous instruction.
When the rule is finished, the relative constituent numbers and any remaining
null constituents in the workspace disappear.</p>
</div>
<div class="paragraph">
<p>§4.2.4 Addressable Storage The 128 shelves, numbered from ¢ through
127, provide the further advantage that comes with addressable
storage. The contents of any one shelf can be moved quickly to the
workspace without a search, merely by mentioning the shelf number.</p>
</div>
<div class="paragraph">
<p>§4.2.4.1 As an example, suppose shelf 5 has a number of A&#8217;s, shelf 6 has B&#8217;s,
shelf 7 has C&#8217;s and shelf 8 has D&#8217;s. It is desired to accumulate on shelf 103
a sequence A + B + C + D + A + B + C + D that continues until one of the
shelves runs out of constituents. The following routine will do it. (Note that
different routing instructions are separated by commas.)</p>
</div>
<div class="listingblock">
<div class="content">
<pre>REAP $ = $0 + $0 + $0 + $0 // *NS 1, *N6 2, *N7 3, *N8 4 *
COUNT $4 = // *Q103 1 REAP</pre>
</div>
</div>
<div class="paragraph">
<p>The process of taking the next constituents from shelves 5, 6, 7, and
8, putting them in the workspace in place of the null constituents,
and queuing them onto shelf 103 will continue until one of the shelves
becomes empty. At this point a null constituent will be brought from
at least one of the shelves. The $4 will then fail to find four
constituents, there being three or less, and the routine will
terminate.</p>
</div>
<div class="paragraph">
<p>§4.2.4.2 When a COMIT program starts, all of the shelves as well as the
work- Space are empty. At times, however, it is necessary to empty a
group of shelves.  The following rule will empty shelves 5, 6, and 7
without disturbing the workspace:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $0 = // *A5 1, *A6 1, *A7 1, *A7 1 *w</pre>
</div>
</div>
<div class="paragraph">
<p>The $0 sets up a null constituent at the left end of the
workspace. The shelving instruction *A5 1 brings everything from shelf
5 into the workspace in place of the null constituent. Shelf 5 is now
empty. The next instruction, *A6 1, brings everything from shelf 6,
which replaces in the workspace what was previously on shelf 5. The
next instruction then clears shelf 7 by bringing everything from it to
the workspace where it replaces the material from shelf 6. All three
shelves are now empty, but the workspace still contains the material
that was on shelf 7. The last routing instruction, *A7 1, then
replaces this material with what is now on shelf 7, namely,
nothing. Thus the workspace is left with a null constituent as before,
and all the material from the shelves has vanished.  The null
constituent disappears before the go-to is executed.</p>
</div>
<div class="paragraph">
<p>§4.2.5 <strong>Exchange</strong> The remaining shelf instruction to be discussed is
the *X23 (exchange) instruction, which, when used, must be written
last in the routing.  It serves to exchange the entire contents of the
workspace for the entire contents of the designated shelf. Thus the
instruction *X23 would exchange the contents of the workspace with the
contents of shelf 23. This instruction is useful when two or more
separate tasks are being carried on concurrently. The exchange
instruction is executed in approximately the time it takes to pass
over two workspace constituents in a left-half search.</p>
</div>
<div class="paragraph">
<p>§4.2.6 <strong>Input and Output</strong> The two most important input and output instructions
are introduced here. They are very simple and are adequate for most input and
output needs. The total facilities provided by COMIT for input and output are
more extensive and extremely flexible. These will be treated in later chapters.</p>
</div>
<div class="paragraph">
<p>§4.2.6.1 Input and output instructions are similar to the shelving
instructions.  Instead of Q, S, A, N, or X to indicate a shelf
operation, they have R for read or W for write. Instead of a shelf
number to designate the source or destination, of the data taken into
or out of the workspace, they have a COMIT channel letter, to
designate the external connection through which the data flows during
reading or writing. And between these two there is a mode
designation. All of this will be spelled out later. For our purposes
now it is sufficient to know that the routing instruction *RCK1 means
read a card from COMIT channel K (the cards that follow the END card
of the COMIT program are data cards and can be read from channel K)
and put it in the workspace where it replaces the workspace expression
having relative constituent number 1, and that the rOuting instruction
*WAM1 2 means to write in format A on the monitor (output) tape the
workspace expressions referred to by the relative constituent numbers
1 and 2.  These are the usual means of reading and writing. If one
wants the output punched on cards instead of printed, one uses COMIT
channel I, the punched- output tape, instead of M; thus we have *WAI1
2.</p>
</div>
<div class="paragraph">
<p>(Editor&#8217;s note: In COMIT Revived, R channels are ignored, with all
input taken from standard input.  In W instructions, channel M directs
to standard error and all other channels to standard output.)</p>
</div>
<div class="paragraph">
<p>§4.2.6.2 As an example of the use of these input and output expressions, the
following complete COMIT program will read a deck of cards, apply the spelling
rule <em>i before e except after c</em>, and punch out a corrected deck.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>A E + I = 2 + 1 /
* C + I + E = 1 + 3 + 2 /
* $ = // *WAI1, *RCK1 A</pre>
</div>
</div>
<div class="paragraph">
<p>§4.2.6.3 In this program, the first two rules will fail on an empty
workspace the first time through. In the third rule, the $ finds an
empty workspace so the write instruction *WAI1 writes out nothing. The
read instruction *RCK1 reads the first card from the input channel K,
puts the material into the work- space one character per constituent,
and follows it by a *. constituent to sym- bolize the end of the
card. Control then goes to A and the spelling rules are applied. When
control again reaches the third rule, the corrected card is found by
the $ and it is punched out by the *WAI1 instruction. The process then
repeats. We thus have a loop that reads, corrects, and punches. All
read instructions will fail to the next rule, called end-of-file
failure, when there is no more input material to be read. In our
program, control exits from the loop when there are no more data cards
to be read. The program terminates because, when the rule with the
read instruction fails, control falls to the END card. This is the
reason that the read instruction was placed in the last rule instead
of in a first rule, ahead of the spelling rules.</p>
</div>
<div class="paragraph">
<p>§4.2.6.4 Another program to do the same thing faster by using shelves is given
below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>A $ + E + I =      // *027 1 3 2 /
* $0 =      // *A27 1 *
* $ + C + I + E =      // *Q27 1 2 4 3 /
* $0 + $ =      // *A27 1, *WAI1 2, *RCK1 A</pre>
</div>
</div>
<div class="paragraph">
<p>4 Each spelling rule places corrected text on shelf 27 so as to reduce search
time. The rearrangement is accomplished by the relative constituent numbers
in the routing.</p>
</div>
</div>
<div class="sect2">
<h3 id="_4_3_summary">4.3 Summary</h3>
<div class="paragraph">
<p>§4.3.0.0 In this chapter, the following left-half notations have been
introduced:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a single constituent.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$-SYMBOL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a single constituent not SYMBOL.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$n (n&gt;l)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">n constituents.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a null constituent.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">any number of constituents, or none.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">n (n&gt;0)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a constituent matching the constituent
             already found and given the relative constituent number n.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>These, together with the simple left-half notations of chapter 2
include all the COMIT notations that refer to workspace constituents
composed of one or more compressed characters. The additional possible
internal structure of constituents will be discussed in the next
chapter.</p>
</div>
<div class="paragraph">
<p>§4.3.0.1 The expand and compress notations have been introduced:</p>
</div>
<div class="paragraph">
<p>*Ecns expand the indicated constituents.</p>
</div>
<div class="paragraph">
<p>*Kcns compress the indicated constituents.</p>
</div>
<div class="paragraph">
<p>where cns is a list of one or more right-half consecutive relative
constituent numbers.</p>
</div>
<div class="paragraph">
<p>§4.3.0.2 All of the shelving instructions have been introduced, except that we
have not yet introduced the scheme for indirectly referring to the shelves via
the workspace constituents.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">*Q<em>sd ns</em></dt>
<dd>
<p><em>queue onto</em> the right end of shelf <em>sd</em> the workspace
expressions with relative constituent numbers <em>ns.</em></p>
</dd>
<dt class="hdlist1">*S<em>sd ns</em></dt>
<dd>
<p><em>store</em> onto the left end of shelf <em>sd</em> the workspace expressions
numbered <em>ns</em>.</p>
</dd>
<dt class="hdlist1">*A<em>sd n</em></dt>
<dd>
<p>take all from shelf sd to the workspace where it will replace the
workspace expression numbered <em>n.</em></p>
</dd>
<dt class="hdlist1">*N<em>sd n</em></dt>
<dd>
<p>take the next (leftmost) constituent from shelf sd to the workspace
where it will replace the workspace expression numbered <em>n.</em></p>
</dd>
<dt class="hdlist1">*Xsd</dt>
<dd>
<p>exchange the data in the workspace for that on shelf <em>sd.</em></p>
</dd>
</dl>
</div>
<div class="paragraph">
<p><em>sd</em> is a shelf designation, 0 through 127, <em>ns</em> is a list of one or
more relative constituent numbers, not necessarily consecutive, and <em>n</em>
is a single relative constituent number.</p>
</div>
<div class="paragraph">
<p>§4.3.0.3 The following input and output instructions have been introduced. They
are the most frequently used ones.</p>
</div>
<div class="paragraph">
<p>*WAMns write in format A on the monitor (printed output) tape the workspace
expressions numbered ns.</p>
</div>
<div class="paragraph">
<p>*WAIns write in format A on channel I (punched output tape) the workspace
expressions numbered ns.</p>
</div>
<div class="paragraph">
<p>*RCKn read in format C (a card, one character per constituent) from
channel K (input) into the workspace, replacing the workspace
expression numbered n.</p>
</div>
<div class="paragraph">
<p>§4.3.0.4 You are now in a position to write rather sophisticated and
powerful COMIT programs. You have control of the most important basic
features. In later chapters you will be introduced to some additional
features that ease the programmer&#8217;s task and allow for much
flexibility.</p>
</div>
</div>
<div class="sect2">
<h3 id="_4_4_problems_for_chapter_4">4.4 Problems for Chapter 4</h3>
<div class="olist upperalpha">
<ol class="upperalpha">
<li>
<p><a id="question4a"></a> Write a test to see if the workspace contains
one A and nothing else. <a href="#answer4a">(Answer)</a></p>
</li>
<li>
<p><a id="question4b"></a> Write a test that will fail if there is
anything in the workspace. <a href="#answer4b">(Answer)</a></p>
</li>
<li>
<p><a id="question4c"></a> Write a test that will fail unless the third
constituent in the workspace is an A. <a href="#answer4c">(Answer)</a></p>
</li>
<li>
<p><a id="question4d"></a> Write a test that will fail if the third
constituent in the workspace is an A. <a href="#answer4d">(Answer)</a></p>
</li>
<li>
<p><a id="question4e"></a> Delete the fifth constituent in the
workspace. <a href="#answer4e">(Answer)</a></p>
</li>
<li>
<p><a id="question4f"></a> Delete the last constituent in the
workspace. <a href="#answer4f">(Answer)</a></p>
</li>
<li>
<p><a id="question4g"></a> Write a rule to put a Z at the right end of the
workspace if there isn&#8217;t one already at the right end. <a href="#answer4g">(Answer)</a></p>
</li>
<li>
<p><a id="question4h"></a> Interchange the second L in the workspace with
the constituent following it. <a href="#answer4h">(Answer)</a></p>
</li>
<li>
<p><a id="question4i"></a> Insert an X after the first adjacent pair of
identical constituents in the workspace. <a href="#answer4i">(Answer)</a></p>
</li>
<li>
<p><a id="question4j"></a> Find the first string of two or more A&#8217;s in the
workspace and delete all but one of the A&#8217;s. <a href="#answer4j">(Answer)</a></p>
</li>
<li>
<p><a id="question4k"></a> Bring everything from shelf 23 to the left end
of the workspace. <a href="#answer4k">(Answer)</a></p>
</li>
<li>
<p><a id="question4l"></a> Bring everything from shelf 23 to the right end
of the workspace. <a href="#answer4l">(Answer)</a></p>
</li>
<li>
<p><a id="question4m"></a> Find the first A immediately followed by a B
and insert the next item from shelf 23 between them. <a href="#answer4m">(Answer)</a></p>
</li>
<li>
<p><a id="question4n"></a> Put everything in the workspace on shelf 23 and
a copy on shelf 24. Leave the workspace empty. <a href="#answer4n">(Answer)</a></p>
</li>
<li>
<p><a id="question4o"></a> Clear shelf 22 and move everything from shelf
23 onto it. <a href="#answer4o">(Answer)</a></p>
</li>
<li>
<p><a id="question4p"></a> Interchange the contents of shelf 22 and shelf
23 without disturbing the workspace. <a href="#answer4p">(Answer)</a></p>
</li>
<li>
<p><a id="question4q"></a> Exchange everything except the first
constituent on shelf 23 with the contents of the
workspace. <a href="#answer4q">(Answer)</a></p>
</li>
<li>
<p><a id="question4r"></a> Exchange everything except the first two
constituents on shelf 23 with the contents of the
workspace. <a href="#answer4r">(Answer)</a></p>
</li>
<li>
<p><a id="question4s"></a> Shelf 23 is empty. Reverse the order of the
constituents in the workspace. <a href="#answer4s">(Answer)</a></p>
</li>
<li>
<p><a id="question4t"></a> The workspace is empty. Reverse the order of
the constituents on shelf 23. <a href="#answer4t">(Answer)</a></p>
</li>
<li>
<p><a id="question4u"></a> Assume the workspace is empty. Test to seee if
shelf 12 is empty. If it is, leave the single constituent EMPTY in the
workspace. Otherwise, leave the single constituent NOT in the
workspace, and leave the shelf as it was. <a href="#answer4u">(Answer)</a></p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_subscripts">SUBSCRIPTS</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_5_1_types_of_subscripts">5.1 Types of Subscripts</h3>
<div class="paragraph">
<p>§5.1.0.0 In this chapter the subscript features of the COMIT language
are presented. There is a system of numerical subscripts that
permits counting and simple arithmetic and a system of logical
subscripts for tagging and classifying constituents and for numerous
other purposes.</p>
</div>
<div class="paragraph">
<p>§5.1.1 <strong>Counting and Arithmetic</strong> There are several ways for determining
when a rule or a routine has been repeated often enough. One of these
ways is by counting the number of times control goes around the loop
and testing to see if it has gone around the right number of
times. This can be done by the use of numerical subscripts, which make
possible the programming of counting and simple arithmetic in COMIT.</p>
</div>
<div class="paragraph">
<p>§5.1.1.1 As an example, figure 21 shows a routine that gives the flow
of control for a program that goes around a loop 100 times under
control of a numerical subscript. (Editor&#8217;s note: flowchart omitted.)</p>
</div>
<div class="paragraph">
<p>§5.1.1.2 Numerical subscripts are represented in the workspace in the
following way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>A + B/.2 + C + D/.l9 + E/.476</pre>
</div>
</div>
<div class="paragraph">
<p>The second constituent has a numerical subscript with a value of 2. The fourth
and fifth constituents have numerical subscripts with values of 19 and 476.</p>
</div>
<div class="paragraph">
<p>Each workspace constituent has a symbol and may have one numerical
subscript.  The part of the constituent on the left of the fraction
bar is called the symbol of the constituent. Subscripts are written to
the right of the fraction bar.  The numerical part of the subscript is
its value. The period distinguishes it as a numerical subscript
instead of a logical subscript. A numerical subscript may have as a
value any integer from O to 32767 (= 2<sup>15</sup> - 1) inclusive.</p>
</div>
<div class="paragraph">
<p>§5.1.1.3 The program, corresponding to the flowchart, that will do something
100 times is as folloWs:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $0 = C/.1 * (insert constituent with numerical subscript)
A _________ * (do something)
* _________ *
* _________ *
* $0 + C/.L100 = 2/.I1 A (test subscnipt and add 1)
* C = $0    * (remove subscript)</pre>
</div>
</div>
<div class="paragraph">
<p>The first rule inserts a constituent at the beginning of the
workspace. This constituent has C as its symbol and .1 as its
numerical subscript. The rule A and the two rules that follow are
assumed to be the rules that do something.  The next to the last rule
has a left-half that will find the C constituent at the left end of
the workspace only if it has a numerical subscript less than 100. This
is represented by the abbreviation .L100. (The left-half subscript
notations .100 and .G100 can be used to indicate tests for a numerical
subscript equal to 100 and greater than 100. The left-half constituent
C/.G7, .L12 would indicate a test for a C having a numerical subscript
greater than 7 and less than 12. Here, the individual left-half
subscript notations .G7 and .L12 are separated by a comma.) The
right-half of the next to the last rule serves to increase the value
of the numerical subscript by one. This is indicated by .I1. (The
abbreviation .D1 will cause the numerical subscript to be decreased by
one. The abbreviation .1 in the right-half will cause a numerical
subscript with the value 1 to be inserted in the workspace on the
indicated constituent where it will replace any value that may already
be there.)</p>
</div>
<div class="paragraph">
<p>§5.1.1.4 Numerical subscripts can also be multiplied and divided. Details will
be given in a later section. There is in addition a machine-language feature
whereby a user can write subroutines in another language, such as one that is
organized around arithmetic computations, and transfer control back and forth
between them and his COMIT program.</p>
</div>
<div class="paragraph">
<p>§5.1.2 <strong>Indirect Addressing</strong> It is possible to specify a shelf number
indirectly by a numerical subscript in the workspace instead of
directly by a number in the shelving instruction. This is done by
replacing the shelf number in the instruction by an * followed by the
relative constituent number of the constituent having the numerical
subscript. Suppose the workspace contains</p>
</div>
<div class="listingblock">
<div class="content">
<pre>A/.15 + B/.23 + 0/.54</pre>
</div>
</div>
<div class="paragraph">
<p>Then the following rule will bring everything from shelf 23 and put it at the
beginning of the workspace:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $ + B = $0 + 1 + 2 // *A*3 1 *</pre>
</div>
</div>
<div class="paragraph">
<p>§5.1.2.1 As another example, the following closed subroutine will place at the
left end of each of the shelves numbered 1 through 127 a constituent A with a
numerical subscript equal to the shelf number:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SN  $ = A/.l *
SHELVE A/.L128 = 1 + 1/.I1 // *S*1 1 /
*  $ = 0 +</pre>
</div>
</div>
<div class="paragraph">
<p>§5.1.3 Logical Subscripts Besides numerical subscripts, COMIT offers a system
of logical subscripts that have a number of important uses. We have seen that
a workspace constituent consists of a symbol and subscripts separated by a
fraction bar. There may be one numerical subscript and any number of logical
subscripts, separated by commas. An example might be the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>GEORGE/.26, SEX MALE, OCCUPATION CLERK, HOBBIES GOLF CHESS</pre>
</div>
</div>
<div class="paragraph">
<p>Each logical subscript consists of a subscript name followed by up to
36 subscript value names. The subscript names and subscript value
names may be freely invented by the programmer and conform to the same
convention as rule names; that is, they can be up to twelve characters
long and composed of letters, numbers, and in medial positions periods
and hyphens.</p>
</div>
</div>
<div class="sect2">
<h3 id="_5_2_subscript_operations">5.2 Subscript Operations</h3>
<div class="paragraph">
<p>$5.2.1 <strong>Insertion and Deletion of Subscripts</strong> Additional logical subscripts may
be inserted on workspace constituents by mentioning them in the right-half of
a rule.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* GEORGE = 1/MARRIED NO *</pre>
</div>
</div>
<div class="paragraph">
<p>They may be deleted by mentioning the subscript name after a minus sign.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* GEORGE = 1/-HOBBIES *</pre>
</div>
</div>
<div class="paragraph">
<p>The subscript mentioned, complete with any values it might have, will
be deleted from the workspace. The right-half subscript expression
-. will delete the numerical subscript, and -$ will delete all
subscripts from a given workspace constituent.</p>
</div>
<div class="paragraph">
<p>§5.2.1.1 Sometimes it is necessary in a rule to mention simultaneously many
values of a subscript. In such a case it is often easier to mention only the
values the subscript does not have, instead of those it does have. This is done
by preceding the values by a minus sign.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* GEORGE = l/EATS -SHRIMP CLAMS *</pre>
</div>
</div>
<div class="paragraph">
<p>This is clearly easier than mentioning the list of things he does
eat. COMIT understands the significance of this notation in the
context of the whole pro- gram. To do this, during the compilation
stage it collects all subscript values mentioned anywhere in the
program as values of the subscript EATS (or as sub- rule names of a
rule EATS) and uses all of these except SHRIMP and CLAMS as
values. This notation is only a shorthand for use in the rule. In the
workspace, the subscript would carry all the values corresponding to
what he does eat .</p>
</div>
<div class="paragraph">
<p>§5.2.2 <strong>Complementing Subscripts</strong> It is possible to replace the values
of a specified subscript in the workspace by the complementary set,
that is, just those values it does not have. This is done by writing
*C after that subscript name in the right-half. As an example, if
George&#8217;s marital status changes, We would write</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* GEORGE = 1/MARRIED*C *</pre>
</div>
</div>
<div class="paragraph">
<p>If the subscript had been MARRIED NO and the only values mentioned
anywhere in the the program were YES and NO, it would change to
MARRIED YES, and conversely.</p>
</div>
<div class="paragraph">
<p>COMIT determines the full set of possible values with respect to which
complementation takes place (here only YES and NO) as all the
different values mentioned anywhere in the COMIT program for that
given subscript or as the set of subrule names associated with a rule
having the same name as the subscript. It should be noted that if
there were also a rule MARRIED, it would have to have among its
subrule names all of the values that any subscripts by that name had.
This will be explained in the next chapter.</p>
</div>
<div class="paragraph">
<p>§5.2.3 <strong>Merging Subscript Values</strong> Besides the insertion, deletion, and
complementing of subscripts, there are other frequently used
operations with sub- scripts. Often a subscript will have only one
value and it is desired to replace this value with another
one. Suppose the workspace contains</p>
</div>
<div class="listingblock">
<div class="content">
<pre>GEORGE/OCCUPATION CLERK</pre>
</div>
</div>
<div class="paragraph">
<p>and it is desired to represent a change of occupation. The following rule:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* GEORGE = 1/OCCUPATION ACCOUNTANT *</pre>
</div>
</div>
<div class="paragraph">
<p>will replace the subscript value CLERK by the subscript value ACCOUNTANT, and
the workspace will contain</p>
</div>
<div class="listingblock">
<div class="content">
<pre>GEORGE/OCCUPATION ACCOUNTANT</pre>
</div>
</div>
<div class="paragraph">
<p>On the other hand, it is often desired not to replace some values with
others but to leave the workSpace subscript with just those values
that both the workspace subscript and the right-half subscript had in
common. For this we would like to have it so that if the workspace
contains</p>
</div>
<div class="listingblock">
<div class="content">
<pre>CULPRIT/POSSIBLY MAID BUTLER DUKE GARDENER</pre>
</div>
</div>
<div class="paragraph">
<p>then the following rule:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* CULPRIT = l/POSSIBLY DUKE NEIGHBOR MAID COOK *</pre>
</div>
</div>
<div class="paragraph">
<p>will reduce the possibilities to only those held in common. The workspace will
then contain</p>
</div>
<div class="listingblock">
<div class="content">
<pre>CULPRIT/POSSIBLY MAID DUKE</pre>
</div>
</div>
<div class="paragraph">
<p>§5.2.3.1 In order to allow for both of these possibilities, a
convention is adopted in COMIT to make possible the use of the same
type of right-half subscript notation without confusion or ambiguity
for both the replace and the and operation. The combined operation is
called merging. It operates in the following way: If the right-half
subscript has no value names in common with the workspace subscript,
the right-half values are substituted for the old workspace values
(replacement). But if the right-half subscript does have values in :
common with the workspace subscript, the new workspace Subscript will
have just those overlapping values that both the right-half subscript
and the old workspace subscript had in common (and operation).</p>
</div>
<div class="paragraph">
<p>§5.2.3.2 Thus the right-half notation is appropriately interpreted in
the most usual situations. The result is always replacement if the
right-half has just one value; the result is always replacement
(actually insertion) when the workspace Subscript has no values; and
the result is always replacement (actually deletion) when the
right-half subscript has no values. If none of these situations holds
and replacement is the desired operation, the old workspace values can
be deleted before the new values are inserted. The following rule will
always replace the values on the subscript SUB no matter which ones or
how many it had:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $1 = 1/SUB, SUB FIRST SECOND * 6</pre>
</div>
</div>
<div class="paragraph">
<p>§5.2.3.3 In those cases where the and operation is the desired one, it is often
guaranteed by the nature of the task being programmed that there will be an
overlap. In those cases where overlap would not normally be expected in every
case, it can be ensured by the simple expediEnt of always carrying an extra,
otherwise unused value (say Z) in both workspace and rule to ensure overlap by
at least one common value.</p>
</div>
<div class="paragraph">
<p>§5.2.4 <strong>The Or Operation</strong> Sometimes it is required that the subscript
values in the workspace be combined with the subscript values in the
right-half in such a way that the workspace subscript is left with
just those values that the workspace subscript or the right-half
subscript or both had. It was not deemed necessary to provide a
Special notation in COMIT for this less frequent operation in light of
the well-known fact that its effect can be had by combining the and
and the complement operations. Thus we know from logic that A or B =
-(-A and -B), where - means not or complement of. The procedure is to
complement the workspace subscript values, then merge (and operation)
with the complement of the right-half subscript values, then
complement the result. It would be written as in the following rule,
which will replace the old values on the workspace subscript SUB with
new ones such that each new value either was an old value on the
workspace subscript SUB or it was a value written in the right-half
subscript SUB (or it was in both places):</p>
</div>
<div class="listingblock">
<div class="content">
<pre>OR $1 = 1/SUB*C, SUB -VAL1 VAL2, SUB*C *</pre>
</div>
</div>
<div class="paragraph">
<p>It is of course assumed that, as usual, there is at least one value in common
when using the and operation.</p>
</div>
<div class="paragraph">
<p>§5.2.5 <strong>Order of Subscripts and Values</strong> Since subscripts are merged,
not inserted, when the workspace constituent already has a subscript
with the same name, it is clear that a workspace constituent can never
have more than one subscript with the same name. And although the
order of constituents in the workspace is sig- nificant, so that A + B
is not the same as B + A, the order of subscripts on a constituent in
the workspace and the order of the values in a subscript are not
significant, so that A/S, T is the same as A/T, S and A/S X Y is the
same as A/S Y X.</p>
</div>
<div class="paragraph">
<p>§5.2.6 <strong>Carrying Over of Subscripts</strong> In the preceding sections, the subscripts
that were inserted in the workspace or merged with workspace constituents came
from the right-half of a rule. It is also possible to insert or merge
subscripts found in the workspace.</p>
</div>
<div class="paragraph">
<p>§5.2.6.1 As an example, suppose the workspace contains either</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SUBJECT/NUMBER SINGULAR + VERB</pre>
</div>
</div>
<div class="paragraph">
<p>or</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SUBJECT/NUMBER PLURAL + VERB</pre>
</div>
</div>
<div class="paragraph">
<p>and it is desired to insert a subscript on VERB that will make the Verb agree
with the number of the subject, that is, have the same subscript. For this we</p>
</div>
<div class="paragraph">
<p>can use the following rule:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* SUBJECT + VERB = 1 + 2/NUMBER*1 *</pre>
</div>
</div>
<div class="paragraph">
<p>The right-half subscript instruction specifies that the NUMBER subscript is to
be carried over from the number one constituent as found by the left-half, and
inserted or merged onto the number two constituent. The result in the workspace
will be either</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SUBJECT/NUMBER SlNGULAR + VERB/NUMBER SINGULAR</pre>
</div>
</div>
<div class="paragraph">
<p>or</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SUBJECT/NUMBER PLURAL + VERB/NUMBER PLURAL</pre>
</div>
</div>
<div class="paragraph">
<p>§5.2.6.2 As another example, logical subscripts can be used to
represent, for German words, the.various possibilities of gender,
number, and case that could be assigned to them by a dictionary. When
words appear in a phrase, such as a noun phrase composed of an article
followed by a noun, some of the possibili- ties of gender, number, and
case for each word would in general not be possible in View of the
necessity of grammatical agreement with the other word. In German,
there are 16 possible combinations of gender, number, and case. There
are the 4 possibilities of gender and number: masculine singular,
feminine singular, neuter singular, and plural; and 4 possibilities of
case: nominative, genitive, dative, and accusative. But there are
fewer than 16 forms for each word since some forms are ambiguous. A
given word form can be marked in the dictionary as to which ones of
these 16 possibilities it can be. This would be done by assigning to
each word a subscript with the proper set of values chosen from these
16 possibilities:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>/GNC MN MG MD MA FN FG FD FA NN NG ND NA PN PG PD PA</pre>
</div>
</div>
<div class="paragraph">
<p>where GNC is the subscript name and means gender-number-case, M means
masculine' N means nominative, and so on. The following rule would
carry over both origin-workspace subscripts to the other constituent
and carry out a merge operation on each, which will be interpreted as
an and operation. It could thus reduce the gender-number-case
ambiguity of both an article and a noun when they appeared together.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* ART + NOUN = 1/GNC*2 + 2/GNC*1 *</pre>
</div>
</div>
<div class="paragraph">
<p>§5.2.6.3 It is also possible to carry over all of the subscripts that
a constituent may have. This is indicated by the following right-half
subscript instruction:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/$*__j__</pre>
</div>
</div>
<div class="paragraph">
<p>where j is a relative constituent number that refers to the
constituent from which the subscripts are to be carried over. This
instruction will also carry over a numerical subscript if there is one
(replacement). The numerical subscript alone will be carried over if</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/-*__j__</pre>
</div>
</div>
<div class="paragraph">
<p>is written in the right-half. A numerical subscript will be carried over and
i added to or subtracted from another if the right-half contains
/.1.*<em>j</em></p>
</div>
<div class="paragraph">
<p>or</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/.D.*j</pre>
</div>
</div>
<div class="paragraph">
<p>§5.2.7 <strong>The Left-Half Search with Subscripts?</strong> The general rationale
behind the left-half notations for specifying searches includes an
emphasis on reducing to a minimum the amOunt of writing that the
programmer has to do. Thus the programmer does not have to be any more
explicit than necessary to uniquely specify the workSpace constituent
of interest to him. If there is only one constituent in the workspace
or if the one he wants is the first one on the left, a simple $1 will
suffice to find it, no matter what its symbol may be and no matter
what subscripts it may have. Likewise a left half <em>SYMBOL</em> or
$-<em>SYMBOL</em> will find a workspace constituent on the basis of the
symbol match and independent of any subscripts. If the left-half
expression $1, $-<em>SYMBOL</em>, or <em>SYMBOL</em> has a subscript expression on
it, then, not only must the symbol part match, but also the subscript
part must match; it is irrelevant whether the workspace constituent
has additional subscripts or not. Similarly, if both a subscript name
and one or more values are specified, the workspace constituent must
have at least this subscript and, for this subscript, at least these
values in order to match. We might call this the principle of minimum
necessary specification.  It operates roughly in English too. We don&#8217;t
say "that diamond gray 1959 VW sunroof sedan with no radio antenna,
red wheels, New York license 123456,&#8230;&#8203;," when "that car" or "that VW”
or "that car with New York plates" will do to distinguish it from the
rest of the objects in question.</p>
</div>
<div class="paragraph">
<p>§5.2.7.1 Suppose the workspace contains a number of constituents of the GEORGE
type, as discussed earlier, and it is desired to search for someone that is
male, unmarried, a professional radio operator, and an amateur mountain climber.</p>
</div>
<div class="paragraph">
<p>The following left-half will set up this search:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $1/SEX MALE, MARRIED NO, OCCUPATION RADIO-OPRTR, HOBBIES MOUNTAINEER =</pre>
</div>
</div>
<div class="paragraph">
<p>But if only a radio operator is needed, then the following would suffice:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $1/OCCUPATION RADIO-OPRTR =</pre>
</div>
</div>
<div class="paragraph">
<p>§5.2.8 Other Subscript Operations Other operations with subscripts can be built
up out of the search, merge, and complement Operations. Two examples follow.</p>
</div>
<div class="paragraph">
<p>§5.2.8.1 Test to see if two subscripts have values in common: Suppose that the
constituents A and B in the workspace both have a subscript SUB and it
is re quired to find out whether they have values in common. The
following rules will do it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* A + B = 1 + 2 + Q/SUB*1, SUB*2 + Q/SUB*2, SUB*1 *
* Q + 1 = 0 YES</pre>
</div>
</div>
<div class="paragraph">
<p>If the subscripts SUB on A and B have values in common, the merge
operation will be interpreted as and, leaving just the values they
have in common on the new subscripts on the Q&#8217;s. The left-half search
in the next rule will succeed.  But if the subscripts on A and B do
not have values in common, the merge operation will be interpreted as
replace, and since the order of replacement is different on the two
Q&#8217;s, the resulting sets of values will be different and the left-half
search in the next rule will fail.</p>
</div>
<div class="paragraph">
<p>§5.2.8.2 Suppose that the constituents A and B in the workspace both have a
subscript SUB and it is desired to insert a constituent D in the workspace
with a subscript SUB having all the values that the subscript on A has, or
the subscript on B has, or both. We assume that if both the subscript on A
and the subscript on B are complemented, the resulting subscripts will have
values in common. This is a fact that the programmer usually knows, and he can
test for it if he doesn&#8217;t. The following routine will do it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* A + B = 1/SUB*C + 2/SUB*C *
* A + B = 1/SUB*C + 2/SUB*C + D/SUB*1, SUB*2, SUB*C *</pre>
</div>
</div>
<div class="paragraph">
<p>To understand how this routine works, one must realize that the numbers written
in the right-half refer to left¥half relative constituent numbers, which of
course refer to the constituents as originally found in the left-half search
and before they have been replaced by the new constituents as specified by the
right-half operations.</p>
</div>
<div class="paragraph">
<p>§5.2.9 <strong>Numerical Sorting</strong> Suppose the workspace contains a number of
constituents, each with a numerical subscript, and it is desired to
sort them into numerical order. There are many schemes for sorting. Of
these, perhaps the simplest, although certainly not the most
efficient, method is the method of repeatedly exchanging adjacent
items if they are out of order.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $1 + $l/.L.*1 = 2 + 1 /</pre>
</div>
</div>
<div class="paragraph">
<p>The left-half means: find any constituent that is followed by a
constituent having a numerical subscript less than the numerical
subscript on the number one constituent. Successive interchanges will
thus continally move smaller numbered constituents to the left, and
the rule will fail when no two constituents
are still out of order. If the opposite order had been desired, with the larger
numbers at the left instead of the smaller ones, the letter G for "greater
than" would replace the L for "less than."</p>
</div>
<div class="paragraph">
<p>§5.2.9.1 There are also the left-half subscript expressions /.*<em>j</em> and
/SUB*<em>j</em> that refer to workspace constituents having, respectively, a
numerical subscript or a logical subscript with name SUB that would be
matched by the numerical or logical subscript on the workspace
constituent already found and given relative constituent number <em>j</em>. The
expression $*<em>j</em> cannot be used in the left-half. If it is desired to
refer to workspace constituents having subscripts that would be
matched by all the subscripts on a workspace constituent already
found, one must use data structures that ensure identity of symbols so
that the method of section 4.1.6 can be used. If important information
must be carried in symbols and associated with subscripts, two
constituents can be ‘ used for each item, one with a symbol only and
the other carrying the subscripts on a standard symbol, thus:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>X/.27, SEX MALE, EATS -FISH + ROY</pre>
</div>
</div>
<div class="paragraph">
<p>The left-half, instead of being written</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $1 + $ + 1 =</pre>
</div>
</div>
<div class="paragraph">
<p>would be written</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $1 + $1 + $ + 1 + $1 =</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_5_3_further_applications">5.3 Further Applications</h3>
<div class="paragraph">
<p>§5.3.1 Polish Prefix Notation An important application of numerical subscripts
is the efficient handling in COMIT of data structures that are organized in a
branching tree or hierarchical structure by representing them in a linear form
in the workspace without parentheses. To explain this notation, an example from
logic, the area in which the notation was developed, is most convenient. Take
as an example the logical expression</p>
</div>
<div class="listingblock">
<div class="content">
<pre>(A AND B) 0R (C AND D)</pre>
</div>
</div>
<div class="paragraph">
<p>This is in the ordinary infix notation, that is, the connectives AND
and OR appear between the expressions they connect, and parentheses
are used to distinguish this from other expressions such as</p>
</div>
<div class="listingblock">
<div class="content">
<pre>((A AND B) OR C) AND D</pre>
</div>
</div>
<div class="paragraph">
<p>§5.3.1.1 These expressions could also be represented as trees, as shown in
figure 22.</p>
</div>
<div class="paragraph">
<p>§5.3.1.2 In the Polish prefix notation, due to Lukasiewicz, the connective is
placed to the left of the items it connects and parentheses are removed. The
above two expressions would then be</p>
</div>
<div class="listingblock">
<div class="content">
<pre>OR AND A B AND C D
AND OR AND A B C D</pre>
</div>
</div>
<div class="paragraph">
<p>In spite of the absence of parentheses, it is always possible to read the
expressons unambiguously if it is known for each connective how many items</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/logictree.png" alt="logictree">
</div>
<div class="title">Figure 2. Figure 4. Trees representing logical expressions.</div>
</div>
<div class="paragraph">
<p>it connects. This information could be obtained from a dictionary that
could assign a subscript of 2 to AND and to OR because they are each
binary connectives, and a subscript of $ to A, B, C, and D, because
they do not connect anything.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>OR~2~ AND~2~ A~0~ B~0~ AND~2~ C~0~ D~0~

AND~2~ OR~2~ AND~2~ A~0~ B~0~ C~0~ D~0~</pre>
</div>
</div>
<div class="paragraph">
<p>such an expression can be represented in the workspace in the following way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>OR/.2 + AND/.2 + A/.0 + B/.0 + AND/.2 + C/.9 + D/.0</pre>
</div>
</div>
<div class="paragraph">
<p>In order to be able to refer to subexpressions in an expression, it suffices
to calculate a new set of subscripts that can take the place of parentheses.
This is done by starting the procedure at the left with an initial value of 1,
then moving to the right, each time calculating a new subscript by adding to
the result of the previous step the subscript obtained from the dictionary and
then subtracting one.</p>
</div>
<div class="paragraph">
<p>§5.3.1.3 The procedure can be expressed easily in COMIT in terms of the
following closed subroutine:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>P $ = START/.1 + 1 *
* $1 + $1 = 1 + 2/.I.*l, .D` // *Q23 1 /
* $$ =      // *A23 1 +</pre>
</div>
</div>
<div class="paragraph">
<p>The result for our two expressions would be</p>
</div>
<div class="listingblock">
<div class="content">
<pre>START~1~ 0R~2~ AND~3~ A~2~ B~1~ AND~2~ C~1~ D~0~

START~1~ AND~2~ 0R~3~ AND~4~ A~3~ B~2~ C~1~ D~O~</pre>
</div>
</div>
<div class="paragraph">
<p>We note that if an expression is well-formed, the last subscript must be zero.</p>
</div>
<div class="paragraph">
<p>§5.3.1.4 Now if we insert a marker anywhere in such an expression, it is easy
to locate the subexpression that falls immediately to the right of that marker.
The procedure is simple. Give the marker a subscript one less than that of the
item to its immediate left. The required subexpression then extends to the
right of the marker to and including the first item with a subscript equal to
that of the marker. If the subexpression is removed and the marker left in its
place, the original expression is still well-formed.</p>
</div>
<div class="paragraph">
<p>§5.3.1.5 The following closed subroutine will assign the proper subscript to
a marker MARK and find and remove the subexpression to shelf 23:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>M $1 + MARK = 1 + 2/.*1, .D1 *
* MARK + $ + $1/.*1 = // *Q23 2 3 +</pre>
</div>
</div>
<div class="paragraph">
<p>And the following rule will restore the subexpression to its place:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>R MARK = // *A23 1 +</pre>
</div>
</div>
<div class="paragraph">
<p>§5.3.1.6 In order to make use of the prefix notation internally and
still allow the user to write input expressions in the infix notation,
the following subroutine will translate from fully-parenthesized infix
notation to prefix notation. This routine makes use of the simplifying
assumptions that operators and operands are represented by
one-character symbols and that the operators are all binary and have
been tagged with the subscript OP. A typical expression for
translation might be</p>
</div>
<div class="listingblock">
<div class="content">
<pre>*( + A + *+/OP + *( + B + X/OP + C + *) + *)</pre>
</div>
</div>
<div class="paragraph">
<p>The subroutine for translation is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>T *( + $1 + $1/OP + $1 + *) = 3 + 2 + 4 // *K1 2 3 /
* $ =     // *E1 +</pre>
</div>
</div>
<div class="paragraph">
<p>§5.3.2 <strong>Shelf Zero and the Subroutine Return Pushdown</strong> In chapter 3, on
the flow of control, the pushdown facility for storing subroutine
returns was introduced. We are now in a position to describe in detail
how the mechanism works.  When a go-to such as SUB+RET is executed, a
constituent is set up with SUB as the symbol and RET as a logical
subscript. This constituent SUB/RET is then stored on a special shelf,
shelf zero. Then when a plus go-to is executed, the next constituent
on shelf zero is obtained, its logical subscript is used for a go-to,
and the constituent is deleted.</p>
</div>
<div class="paragraph">
<p>§5.3.2.1 All the shelving instructions also work on shelf zero; so it
is possible to examine and manipulate the contents of the subroutine
return pushdown.</p>
</div>
</div>
<div class="sect2">
<h3 id="_5_4_summary_of_subscript_operations">5.4 Summary of Subscript Operations</h3>
<div class="paragraph">
<p>§5.4.0.0 The following subscript operations either have been introduced
in this chapter or are implied by the ones introduCed. This list
includes all of the left-half subscript expressions and most of the
right-half subscript expressions. The rest will be introduced later in
connection with other topics.</p>
</div>
<div class="paragraph">
<p>§5.4.0.1 Left-half subscript expressions and their meanings:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">/</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">having</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">,</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">and</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">.<em>n</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a numerical subscript with the value <em>n</em>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">.*<em>j</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a numerical subscript with a value equal to the numerical
                sub script on the number <em>j</em> constituent in the workspace.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">.G<em>n</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a numerical subscript with a value greater than <em>n</em>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">.G.*<em>j</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a numerical subscript with a value greater than the numerical
                sunscript on the number <em>j</em> constituent in the workspace.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">.L<em>n</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a numerical subscript with a value less than <em>n</em>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">.L.*<em>j</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a numerical subscript with a value less than the numerical
                subscript on the number <em>j</em> constituent in the
	        workspace.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>SUB</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">at least the subscript <em>SUB</em>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>SUB V1 V2</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">at least the subscript <em>SUB</em> having at least the
                values_V1_ and <em>V2</em>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>SUB</em>- <em>V1 V2</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">at least the subscript SUB having at least all
                     values except  the values V1 and V2.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>SUB</em>-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">at least the subscript SUB having all values (at least
                all values except none).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>SUB</em>*<em>j</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">at least the subscript <em>SUB</em> having at least the
                  values of the subscript <em>SUB</em> on the number <em>j</em>
		  constituent in the workspace.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">-.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no numerical subscript.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">-<em>SUB</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no subscript with the name <em>SUB</em>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">-$</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no subscripts.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>§5.4.0.2 In the case of the left-half operations involving *<em>j</em>, there will be
no match if constituent <em>j</em> does not have the appropriate subscript.</p>
</div>
<div class="paragraph">
<p>§5.4.0.3 Right-half Subscript expressions and their meanings:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">/</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">and then</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">,</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">and then</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">.<em>n</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">set the numerical subscript to <em>n</em>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">.*<em>j</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">set the numerical subscript equal to the numerical subscript on
                the number <em>j</em> constituent in the workspace.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">.D<em>n</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">decrease the numerical subscript by <em>n</em>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">.D.*<em>j</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">decrease the numerical subscript by the numerical subscript on
                the number j constituent in the workspace.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">.I<em>n</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">increase the numerical subscript by n.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">.I.*<em>j</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">increase the numerical subscript by the numerical subscript on
                the number j constituent in the workspace.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>SUB</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">merge in the subscript SUB with no values.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>SUB V1 V2</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">merge in the subscript SUB with values <em>V1</em> and <em>V2</em>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>SUB</em>- <em>V1 V2</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">merge in the Subscript SUB with all values except
                     <em>V1</em> and <em>V2</em>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>SUB</em>-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">merge in the subscript <em>SUB</em> with all values.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>SUB</em>*C</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">complement the values of the subscript <em>SUB</em>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>SUB</em>*j</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">merge in the subscript SUB found on the number <em>j</em> constituent in
                the workspace, with all its values.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$*<em>j</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">merge in all the subscripts found on the number <em>j</em>
                constituent in the workSpace, with all their values.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">-.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">delete the numerical subscript.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">-SUB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">delete the subscript SUB.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">-$</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">delete all the subscripts.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>§5.4.0.4 In the case of the right-half operations involving *<em>j</em>, there
will be no operation carried out if constituent <em>j</em> does not have the
appropriate subscript.</p>
</div>
<div class="paragraph">
<p>§5.4.0.5 When workspace constituents are expanded or compressed, any
subscripts they may have are lost.</p>
</div>
</div>
<div class="sect2">
<h3 id="_5_5_problems_for_chapter_5">5.5 Problems for Chapter 5</h3>
<div class="paragraph">
<p>Assume shelf 23 is available for use if needed.</p>
</div>
<div class="olist upperalpha">
<ol class="upperalpha">
<li>
<p><a id="question5a"></a> The workspace contains a constituent A with a
numerical subscript. Write a test that will fail if the subscript
equals zero; otherwise it will decrease the subscript by one and go to
LOOP. <a href="#answer5a">(Answer)</a></p>
</li>
<li>
<p><a id="question5b"></a> The workspace contains a constituent A with a
numerical subscript. Write a test that will go to LOOP if this
subscript has a value from 37 to 89 inclusive; otherwise it will go to
the next rule. <a href="#answer5b">(Answer)</a></p>
</li>
<li>
<p><a id="question5c"></a> The workspace contains a constituent A with a
numerical subscript. Write a test that will go to LOOP if this
subscript does not have a value from 37 to 89 inclusive; otherwise it
will go to the next rule. <a href="#answer5c">(Answer)</a></p>
</li>
<li>
<p><a id="question5d"></a> The workspace contains three constituents, each
with a numerical subscript.  Replace these by a constituent having the
symbol SUM and a numerical subscript equal to the sum of those on the
original three. <a href="#answer5d">(Answer)</a></p>
</li>
<li>
<p><a id="question5e"></a>0 The workspace contains several
constituents. Number them with numerical subscripts starting with 1 at
the left. <a href="#answer5e">(Answer)</a></p>
</li>
<li>
<p><a id="question5f"></a> The workspace contains several
constituents. Write a routine that will leave the workspace containing
32 = 2<sup>5</sup> copies of its original contents.  Use a numerical subscript
to keep count. <a href="#answer5f">(Answer)</a></p>
</li>
<li>
<p><a id="question5g"></a> Write a routine to find the constituent in the
workspace that has the largest numerical subscript, and leave that
constituent on shelf 23. <a href="#answer5g">(Answer)</a></p>
</li>
<li>
<p><a id="question5h"></a> Assume that the workspace and shelves 51
through 54 are empty. Move the data on shelves 1 through 50 to shelves
5 through 54. Data from shelf 1 goes to shelf 5, shelf 2 to shelf 6,
and so on. <a href="#answer5h">(Answer)</a></p>
</li>
<li>
<p><a id="question5i"></a> Assume that shelves 21 through 50 are empty and
available. It is desired to use these shelves in a pushdown of shelves
arrangement for storing the contents of the workspace. Write two
closed subroutines PUT and FETCH. PUT will put the contents of the
workspace on the next available shelf or go to FULL if there are no
free shelves left. FETCH will bring to the beginning of the workspace
the contents of the most recently filled shelf or go to EMPTY if all
the shelves are empty. Assume that shelf 20 contains a single
constituent A with a numerical subscript for keeping track of the
current shelf. This subscript has been set originally to 20.
<a href="#answer5i">(Answer)</a></p>
</li>
<li>
<p><a id="question5j"></a> Write a test to see if George is married or
not. Go to either rule YES or rule NO. ASSume constituents and
subscripts in the workspace like those used in the text as
examples. <a href="#answer5j">(Answer)</a></p>
</li>
<li>
<p><a id="question5k"></a> Write a routine to test if George eats
everything. Go to either YES or NO.  Assume that he eats something.
<a href="#answer5k">(Answer)</a></p>
</li>
<li>
<p><a id="question5l"></a> Write a test to see if there are at least three
constituents in the workspace with a subscript A. If there are, go to
YES. <a href="#answer5l">(Answer)</a></p>
</li>
<li>
<p><a id="question5m"></a> Write a test to see if the second constituent
in the workspace has at least a subscript FURNITURE with at least the
values TABLE and DESK. <a href="#answer5m">(Answer)</a></p>
</li>
<li>
<p><a id="question5n"></a> Write a test to see if there is an adjacent
pair of constituents in the workspace, the second of which has the
same symbol as the first, the same numerical subscript if the first
one has one, and at least the same logical subscripts, each with at
least the same values as those on the first. <a href="#answer5n">(Answer)</a></p>
</li>
<li>
<p><a id="question5o"></a> Assume shelf 22 contains a file of items. Each
item consists of two constituents. The first has a symbol A and one or
more logical subscripts representing subject index catggories. The
second constituent identifies the document that has been so
indexed. The workspace contains a search request in terms of a
constituent with symbol A and logical subscripts representing the
index categories that must be satisfied for those documents.
desired. Write a closed subroutine SEARCH that will remove to shelf 23
those items that satisfy the search request. Leave the rest of the
items on 22 and the search request in the workspace.  <a href="#answer5o">(Answer)</a></p>
</li>
<li>
<p><a id="question5p"></a> The workspace contains a constituent with a
logical subscript Q having at least two values, but possibly
more. Write a rule that will remove the value C if it is present.
<a href="#answer5p">(Answer)</a></p>
</li>
<li>
<p><a id="question5q"></a> Why cannot the above rule be used to remove the
value C if it is the only value present?  <a href="#answer5p">(Answer)</a></p>
</li>
<li>
<p><a id="question5r"></a> What practical way can be used in a COMIT
program so that the above rule will always work correctly?
<a href="#answer5r">(Answer)</a></p>
</li>
<li>
<p><a id="question5s"></a> The workspace contains a constituent with a
logical subscript Q. Write a rule to add the value C to this
subscript. <a href="#answer5s">(Answer)</a></p>
</li>
<li>
<p><a id="question5t"></a> When would this rule fail to work properly, and
what is to be done about <a href="#answer5t">(Answer)</a></p>
</li>
<li>
<p><a id="question5u"></a> A board game is played on a 5 x 5 checkerboard
of 25 squares. Each piece is an irregularly shaped cardboard that will
just cover one or more squares and may be played only if those squares
are not already covered. Assume the workspace contains two
constituents: PIECE, with subscript SQUARES and values indicating
which squares that piece covers; and BOARD, with subscript SQUARES and
values indicating which squares are still not covered.  Write a test
that goes to FIT if the piece can be played, otherwise to the next
rule. Leave the workspace undisturbed in either case. <a href="#answer5u">(Answer)</a></p>
</li>
<li>
<p><a id="question5v"></a> Write a closed subroutine PLAY that will play a
piece that fits in the above game. To play a piece, change the
subscript values on the constituent BOARD to reflect the additional
squares covered, and delete the constituent PIECE. Assume that a 26th
square has been defined that is never covered. <a href="#answer5v">(Answer)</a></p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_branches_and_subrules">BRANCHES AND SUBRULES</h2>
<div class="sectionbody">
<div class="paragraph">
<p>§6.0.0.0 Consider a subroutine for writing an invitation to a
person. Part of the logic should consist of asking whether the person
is single, or a married man, or a married woman. One branch will
consist of a three-way choice between paths leading to writing either
"you,” or "you and your wife," or "you and your husband."</p>
</div>
<div class="sect2">
<h3 id="_6_1_subrules_and_the_dispatcher">6.1 Subrules and the Dispatcher</h3>
<div class="imageblock">
<div class="content">
<img src="images/invitation.png" alt="invitation">
</div>
<div class="title">Figure 3. Figure 5: Part of a program for generating invitations.</div>
</div>
<div class="paragraph">
<p>§6.1.1 <strong>Preset Program Branches</strong> There are many circumstances where the
decision as to which branch in a program should be taken can best be
made at an earlier point in the program before control has reached the
branch point. In the example we have been discussing, it would be
much easier to test whether that person was single, etc., at the much
earlier point in the program where the list of names was being
examined to determine whether there was still an unchecked name on the
list (figure 3). If the test were put there and the branch kept in its
original place, the result of the test would have to be remembered for
the intervening period.</p>
</div>
<div class="paragraph">
<p>§6.1.1.1 In COMIT, the result of a test destined to effect a later
branch of control is remembered in a special section of memory called
the dispatcher.  The dispatcher is like the logical subscripts of a
constituent, but it is not in the workspace or on a shelf. Each
dispatcher entry is in the form of a logical subscript that can be set
to control a program branch.</p>
</div>
<div class="paragraph">
<p>§6.1.1.2 The flowchart is illustrated in figure 5.</p>
</div>
<div class="paragraph">
<p>§6.1.1.3 The relevant parts of the COMIT program corresponding to this
flowchart are</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* (unchecked off name?)                    **
*                                          OUT
* (Single?)               // GUEST SINGLE  CHECK-OFF
* (man?)                  // GUEST HUSBAND CHECK-OFF
*                         // GUEST WIFE    *
CHECK-OFF                                  *
                          .
		          .
		          .
GUEST SINGLE    $ = -YOU                   *
HUSBAND           = -YOU-AND-YOUR-WIFE     *
WIFE              = -YOU-AND-YOUR-HUSBAND  *
* $ =                     // *WAMl         *</pre>
</div>
</div>
<div class="paragraph">
<p>In this section of program, the third, fourth, and fifth rules contain
dispatcher instructions written in the routing. These instructions
operate like logical subscript expressions in the right-half in that
they merge with the current dispatcher subscript entry to give a new
one. In the operations shown, the new value will replace the old
value, whatever it might have been. When a COMIT program is started,
each dispatcher subscript entry starts out with no values.</p>
</div>
<div class="paragraph">
<p>§6.1.1.4 This new value is retained as the setting of the dispatcher
for GUEST.  When the flow of control eventually reaches the rule
GUEST, the correct one of the three branches is taken. These three
branches are the three subrules of the rule GUEST. Each subrule has a
subrule name: SINGLE, HUSBAND, or WIFE, and the choice of which
subrule of the three is executed is determined by the current setting
of the dispatcher entry GUEST. It is to be noted that the rule GUEST
has a single left-half, but each subrule can have its own right-half,
routing and go-to. The * go-to on any subrule means, of course, to go
to the next rule, and if there is failure in the left-half, control
similarly goes to the next rule.</p>
</div>
<div class="paragraph">
<p>§6.1.1.5 It is thus clear that there is a correspondence between subscript
names and rule names, and between subscript value names and subrule names. In
fact, if a rule and a subscript have the same name, the set of subrule names
is taken to be the complete set of possible value names for the subscript. If
a subscript name is the same as a rule name, the associated subscript value
names must all be chosen from among the subrule names of the rule. Also, rules
having the same name must have identical sets of subrule names in the same
order.</p>
</div>
<div class="paragraph">
<p>§6.1.2 <strong>Multiple Position Switch</strong> Another example of the use of the
dispatcher to control the choice of Subrules is this subroutine for
dealing a hand of bridge. We assume that shelf 5 contains 52
constituents representing 52 cards and that they are to be dealt out
one at a time onto shelves 11, 12, 13, and 14.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>DEAL                 // HAND EAST           *
NEXT          $ =    // *N5 1               *
HAND NORTH   $1 =    // *S11 1, HAND EAST   NEXT
     EAST            // *S12 1, HAND SOUTH  NEXT
     SOUTH           // *S13 1, HAND WEST   NEXT
     WEST            // *S14 1, HAND NORTH  NEXT
*     +</pre>
</div>
</div>
<div class="paragraph">
<p>§6.1.2.1 The first rule sets the dispatcher to start the deal with
EAST. The rule NEXT brings the next card off of shelf 5. The rule HAND
has four subrules for NORTH, EAST, SOUTH, and WEST. Initially the
subrule EAST is chosen. This subrule stores the card on shelf 12,
changes the dispatcher setting to the next subrule, SOUTH, and goes to
the rule NEXT, which brings the next card off of shelf 5. The process
will continue, dealing the cards from shelf 5 in turn onto shelves 11,
12, 13, and 14, until there are no more cards on shelf 5.  When this
happens, the rule NEXT will bring a null constituent off the shelf
leaving an empty workspace. The left-half of the rule HAND will fail,
and the routine will terminate with a + go-to. Note again that the
rule with several subrules has only one left-half, written in the
first subrule. A rule may have up to 36 subrules.</p>
</div>
<div class="paragraph">
<p>§6.1.3 Random Choice In certain types of programs, the introduction of
a random element is essential. In COMIT, there is a feature that
provides for the random choice‘of subrules during execution of a
program. When execution of a program begins, the initial state of the
diSpatcher is that it contains a logi- cal subscript for each rule
name or subscript name that has subrule names or value names
associated with it. But none of these dispatcher subscripts has any
values; so the dispatcher contains no information for choosing among
subrules during execution. In this situation, the choice of subrule to
be executed is determined automatically by a simple internal
mathematical routine that supplies a sequence of "pseudo-random"
numbers. Since the routine is deterministic, it will supply the same
sequence of pseudo-random numbers each time the COMIT program is run
- this amount of predictability is a great aid in finding programming errors.</p>
</div>
<div class="paragraph">
<p>§6.1.3.1 An example of the use of the random choice of Subrules is the
following routine to shuffle a deck of cards. We assume that each card
is repre- sented by a constituent and that the deck has been cut, part
of the cards being on shelf 2 and the remainder on shelf 4. The
routine shuffles these two partial decks together and places them on
shelf 3.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SHUFFLE LEFT $ = // *NZ 1 *
RIGHT // *N4 1 * ﬂ
* $1 = // *Q3 1 SHUFFLE
* $ = $¢ + $® // *A2 1, *A4 2, *Q3 1 2 +</pre>
</div>
</div>
<div class="paragraph">
<p>§6.1.3.2 Another example of a routine involving random choice is a
simple Markov source, which produces a sequence of symbols with
statistical properties characteristic of the source. The state diagram
of one Such Markov source is given in figure 6, with the output
symbols and transition probabilities
indicated.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/markov.png" alt="markov">
</div>
<div class="title">Figure 4. Figure 6. State diagram of a Markov source.</div>
</div>
<div class="paragraph">
<p>§6.1.3.3 The program is given below. The output symbols are written on the
monitor tape.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>S0 1  $ = A // *WAMI S1
   2    = B // *WAMI S2
   3    = B // *WAMI S2
S1 1  $ = A // *WAMl S0
   2    = A // *WAMl S2
S2 1  $ = A // *WAMl S0
   2    = A // *WAMl S0
   3    = B // *WAMl S1</pre>
</div>
</div>
<div class="paragraph">
<p>§6.1.4 <strong>Limited Random Choices</strong> Suppose we have the following rule in a program:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>FLAVOR A $ = VANILLA      *
       B   = CHOCOLATE    *
       C   = STRAWBERRY   *
       D   = COFFEE       *
       E   = ORANGE       *
       F   = LIME         *</pre>
</div>
</div>
<div class="paragraph">
<p>We have seen that if the dispatcher has not been set, there will be a random
choice from among the six subrules; and if the dispatcher has been set to one
of the subrules, say by a dispatcher instruction FLAVOR E, then that subrule
is selected. There is a third possibility; the dispatcher can be set to several
of the subrules and the random choice will then be limited to those subrules.
If the dispatcher were set to FLAVOR C E F, there would be a random choice of
strawberry, orange, or lime.</p>
</div>
<div class="paragraph">
<p>§6.1.4.1 When a dispatcher instruction is executed, the new dispatcher
entry is merged into the entry already in the dispatcher in the same
way that subscripts are merged. Let us assume that the dispatcher
contains FLAVOR A B C.</p>
</div>
<div class="paragraph">
<p>If a dispatcher instruction FLAVOR B C D is executed, the dispatcher
will contain the values in common, FLAVOR B C. But if the dispatcher
instruction is FLAVOR A B or FLAVOR D E, the dispatcher will contain
the new values in either case. The dispatcher subscript may be cleared
for a completely random choice again by the entry FLAVOR, with no
values indicated. Therefore, to reset a dispatcher subscript when it
is not known what values it has, two entries should be used, one to
clear the subscript and the other to reset it: FLAVOR, FLAVOR
B C D. The routing instruction *D- will clear the complete dispatcher.</p>
</div>
<div class="paragraph">
<p>§6.1.5 <strong>Merging Dispatcher Subscripts onto Workspace Constituents</strong> The righthalf subscript instructions</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/ __SUB__*D
/ $*D</pre>
</div>
</div>
<div class="paragraph">
<p>are similar in operation to the right-half subscript instructions</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/ __SUB__*__j__
/ $*__j__</pre>
</div>
</div>
<div class="paragraph">
<p>(see section 5.2.6) except that the subscripts are carried over and merged onto
the workspace constituent from the dispatcher instead of from the constituent
having the relative constituent number j.</p>
</div>
<div class="paragraph">
<p>§6.1.6 <strong>Merging Subscripts into the Dispatcher</strong> The following COMIT rule
will merge into the dispatcher all of the subscripts on the indicated
workspace con- stituent.</p>
</div>
<div class="paragraph">
<p>An example of the use of a rule like this is in the following routine
that obtains the spelling of a verb from a dictionary and adds the
correct inflection.  We assume that the workSpace contains a
constituent that specifies, by means of subscripts, which verb is
desired and how it should be inflected.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>A/VERB C, INFL lNF</pre>
</div>
</div>
<div class="paragraph">
<p>The routine first sets the dispatcher for these values. The verb stem
is obtained from the rule VERB. The correct inflectional category is
indicated in the go-to, where control passes to one of the two INFL
rules. (More than two would actually be needed for English.) Finally,
the exit is to rule R, and the workspace contains the correctly
inflected verb.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>*      $1 =       // *D1 *
VERB A $1 = LIK          B
     B    = WALK         A
     C    = LOOK         A
     D    = BOR          B
     .      .
     .      .
     .      .
A                        *

INFL INF $1 =            R
     3RD    = 1 + S      R
     PAST   = 1 + ED     R
     PART   = 1 + ING    R
B                        *
INFL INF $1 = 1 + E      R
3RD         = 1 + ES     R
PAST        = 1 + ED     R
PART        = 1 + ING    R</pre>
</div>
</div>
<div class="paragraph">
<p>§6.1.6.1 It is worth noting the use of rules A and B with asterisk
go-to&#8217;s and no center sections. They serve merely to direct the flow
of control to one or the other of the two rules named INFL. Although
it is legal to have two or more rules by the same name, as in the case
of INFL, this name cannot be used as a go-to without causing an
undefined go-to error. It is also worth noting that no confusion is
caused if the same name is used as a rule name and a subrule name, or
as a subscript name and a value name.</p>
</div>
</div>
<div class="sect2">
<h3 id="_6_2_fast_search_of_left_halves">6.2 Fast Search of Left-Halves</h3>
<div class="paragraph">
<p>§6.2.1 List Rules Consider the following program for word-for-word
substitu- tion. We assume that the workspace contains a German
sentence. Each letter is a constituent and words are separated by -
characters, representing spaces.  There is no punctuation, but a - at
the beginning and at the end. It is desired to look the words up in a
list, substitute English "equivalents," and print them out.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>A - + $ + - + $ = // *WAM1, *KZ, *Q5 3 4 DICT
*    STOP
DICT  IST = IS    B
*     DER = THE   B
      .
      .
      .

B  $ = // *WAM1, *A5 1 A
STOP  *</pre>
</div>
</div>
<div class="paragraph">
<p>§6.2.1.1 What we are really doing in this program is searching through
a number of rules for a left-half that matches the workspace. The
trouble with the program is that it will run quite slowly if the list
is very long. In COMIT, there is a facility for writing an equivalent
program that runs quite rapidly:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>A - + $ + - = // *WAMl, *L2 DICT
*    STOP
-DICT IST = IS   B
      DER = THE  B
          .
	  .
	  .
B $ + - =    // *WAM1  A
STOP    *</pre>
</div>
</div>
<div class="paragraph">
<p>§6.2.1.2 In this program, the first rule locates a word as a string of
characters between spaces. The first space is written out. The routing
instruction *L2 says to compress these characters temporarily into one
constituent without subscripts and look it up in the list mentioned in
the go-to DICT. The list rule -DICT is distinguished by a hyphen (or
minus sign) in column 1. The left-halves of the various list subrules
are single constituents. Each list subrule can have a normal
right-half, routing, and go-to. If the temporarily compressed
constituent cannot be found in the list, the original uncompressed
constituents are restored to the workspace complete with their
subscripts, and control goes to the rule after the list rule (rule B).</p>
</div>
<div class="paragraph">
<p>§6.2.1.3 This program, written with a list rule, will run much faster than the
other program because the COMIT compiler automatically sorts the left-halves
of the list subrules into alphabetic order. Then whenever a constituent is
looked up in a list, COMIT can use a fast search procedure. If there are more
than a few items in the list, the list-rule method is to be preferred.</p>
</div>
<div class="paragraph">
<p>§6.2.1.4 If a routing section contains several instructions, the *L
must be the one written last. This is true also of the *X exchange
instruction; it too must be written last, but there would never be an
occasion for using both in the same routing section. It is important
that a list rule never be entered without having just executed a *L
instruction to specify what is to be looked up in the list. Thus it is
an error to enter a list rule by left-half failure in the preceding
rule. It is good programming practice to anticipate this problem by
always writing a special rule above the list rule to catch the flow of
control in case of left-half failure. In the example, the rule between
A and -DICT will do this.</p>
</div>
<div class="paragraph">
<p>§6.2.1.5 There is no limit to the length of a list rule except the
number of memory registers available in the core memory of the
computer. A list rule to look up words in a dictionary and tag each
with a logical subscript and values could contain up to 4,000 or 5,000
entries before running out of space in core memory. If it is important
to have a large number of list subrules, space can be saved by using
an asterisk go-to in each subrule rather than any other kind, since
the asterisk go-to saves one register of computer memory per list
subrule over any other type of go-to.</p>
</div>
<div class="paragraph">
<p>§6.2.1.6 The only problem introduced by using the asterisk go-to in
list subrules is that control will go to the next rule whether the
item is found in the list or not. Therefore, unless it is known that
items looked up in the list will always be found, a test should be
added to the program to determine whether the item had been found or
ngt. For example, if the item to be looked up originally consists of
two or more constituents, the test $0+$1+$0 for a single constituent
would fail if the item had not been found. As another ex- ample,
$0+$1/-$ would fail if the item looked up had not been given a
subscript by a list subrule right-half.</p>
</div>
<div class="paragraph">
<p>§6.2.2 <strong>Input Control of Program</strong> A user who has a specific and narrow
set of tasks in mind will often write, in a compiler language, a
program that is general enough to do all of the tasks of interest to
him in response to brief instruc- tions that he invents for the
purpose. An interesting example of how this can be done uses a list
rule and shelves. Suppose one has some elementary special-purpose
COMIT closed subroutines for processing particular types of
data. These routines have been named READ, WRITE, INSERT, REMOVE,
SKIP, BACK, and LOOK. In addition, there are some higher-level closed
subroutines that call some of these elementary subroutines using the
A+B type of go-to. The higher-level rou- tines might be called EDIT,
PROCESS, BRING, SAVE, PREPARE, FINISH, and so on.  The user would like
to treat these words as a higher-level programming language so that he
can write a program, in terms of these words, for each different data
set. The following COMIT routine allows him to do this. He can punch
his higher-level program on cards using these words, stack these cards
behind the END card of his COMIT program, and follow with a data set.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>D $ =     // *Q23 1 WORD+INTERPRET
INTERPRET $1 =     // *L1 F
* $ =     // *A231, *S01 +
-F READ    = A/READ D
   WRITE   = A/WRITE D
   INSERT  = A/INSERT D
   REMOVE  = A/REMOVE D
   SKIP    = A/SKIP D
   BACK    = A/BACK D
   LOOK    = A/LOOK D
   EDIT    = A/EDIT D
   PROCESS = A/PROCESS D
   BRING   =  .
   SAVE    =  .
   PREPARE =  .
   FINISH  =  .
* ERROR</pre>
</div>
</div>
<div class="paragraph">
<p>§6.2.2.1 The above routine is entered at rule D with an empty
workspace; thus the first time through, the shelving instruction has
no effect. Control goes to a closed subroutine WORD, not shown, This
subroutine will read the cards following the END card, using input
instructions that will be described later, and will return control via
a + go-to to the rule INTERPRET. We assume that when control returns
from WORD, there will be a word, compressed into one constituent, in
the workspace; but if the end of the user&#8217;s program of words has been
reached, the workspace will be empty. The rule INTERPRET will cause
the list rule to be entered to look up the word. Each list subrule
replaces a word by one or more constituents with logical
subscripts. The point of this is that after all the words of the
user&#8217;s program have been translated, they are placed on shelf zero
where the subscripts can be used as go-to names when a + go-to is
executed. This process is started by the + go-to in the third rule. In
this way the user&#8217;s program controls the flow of control in the COMIT
program. If the user misspells a word or uses a word not in the list,
the list rule fails and control goes to the next rule and subsequently
to ERROR.</p>
</div>
<div class="paragraph">
<p>§6.2.3 <strong>List Rule Execution</strong> In order to clarify the exact operation of the list
rule, it is worthwhile to consider how the relative constituent numbers are
assigned and changed during the execution of the rule with the *L instruction
and during the execution of the list rule itself.</p>
</div>
<div class="paragraph">
<p>§6.2.3.1 Suppose the workspace originally contains</p>
</div>
<div class="listingblock">
<div class="content">
<pre>A + B + C/D + E + F/G + H + I + J</pre>
</div>
</div>
<div class="paragraph">
<p>and the rule with the *L instruction is</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* B + $2 + $2 + $1 = 1 + 3 + 2 + 4 // *L2 3 LIST</pre>
</div>
</div>
<div class="paragraph">
<p>After the execution of the right-half, the workspace will be rearranged and
assigned right-half relative constituent numbers as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>A + B + F/G + H + C/D + E + I + J
   [1] [2______] [3______] [4]</pre>
</div>
</div>
<div class="paragraph">
<p>It is the constituents numbered 2 and 3 that are specified to be looked up in
the list. The *L2 3 instruction marks these constituents, which we will call
the key.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>F/G + H + C/D + E
[key             ]</pre>
</div>
</div>
<div class="paragraph">
<p>The *L2 3 instruction then compresses copies of the constituents to form what
is called the list long symbol (1.s.), which is to be used in comparing with
the left-halves of the list subrules. The list long symbol would then be</p>
</div>
<div class="listingblock">
<div class="content">
<pre> FHCE
[1.s.]</pre>
</div>
</div>
<div class="paragraph">
<p>The go-to is then executed, and control goes to the list rule itself.</p>
</div>
<div class="paragraph">
<p>§6.2.3.2 In the list rule, the long symbol is compared, by means of a fast
search, with the list subrule left-halves. If there is no match between the
long symbol and a list subrule left-half, the long symbol disappears, the
workspace remains as it was before the list rule was entered, and the list rule
fails, control going to the next rule.</p>
</div>
<div class="paragraph">
<p>§6.2.3.3 But if the long symbol matches one of the list subrule left-halves,
the right-half, routing, and go-to of this subrule are executed. A number 1
written in the right-half refers to the long symbol; but in the absence of a
right-half, a number 1 written in the routing refers to the key. There are
thus several important cases to consider.</p>
</div>
<div class="paragraph">
<p>§6.2.3.4 If the list subrule has no right-half or routing:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>FHCE = R</pre>
</div>
</div>
<div class="paragraph">
<p>the workspace will be left as it was before the list rule was executed and
control will go to the rule R.</p>
</div>
<div class="paragraph">
<p>§6.2.3.5 If the list subrule has a rOuting but no right-half:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>FHCE = // *S23 1 R</pre>
</div>
</div>
<div class="paragraph">
<p>the routing instruction will move the key to shelf 23, which would then
contain</p>
</div>
<div class="listingblock">
<div class="content">
<pre>F/G + H + C/D + E + . . .</pre>
</div>
</div>
<div class="paragraph">
<p>and the workspace would be left with</p>
</div>
<div class="listingblock">
<div class="content">
<pre>A + B + I + J</pre>
</div>
</div>
<div class="paragraph">
<p>§6.2.3.6 If the list subrule has an exchange instruction in the routing and</p>
</div>
<div class="paragraph">
<p>no right-half:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>FHCE = // *X23 R</pre>
</div>
</div>
<div class="paragraph">
<p>the workspace will be left as it was before the list rule was entered, and
then the entire contents of the workspace will be exchanged with shelf 23.</p>
</div>
<div class="paragraph">
<p>§6.2.3.7 At this point it is convenient to introduce a new go-to, the $ go-to.
It operates something like the + go-to except that it refers to the workspace
constituent that has the relative cﬁnstituent number 1 instead of shelf 6 and
the constituent is not deleted. Control goes to the rule with the same name
as the name of the logical subscript on this constituent. The subscript may
have been in the workspace, it may have been introduced from the right-half,
or the constituent may have been introduced by a shelving instruction in the
routing.</p>
</div>
<div class="paragraph">
<p>§6.2.3.8 If a list subrule has no right-half or routing but a $ go-to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>FHCE = $</pre>
</div>
</div>
<div class="paragraph">
<p>the workspace will be left as it was before the list rule was executed, and
the $ will refer to the first constituent in the key:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>F/G + H + C/D + E</pre>
</div>
</div>
<div class="paragraph">
<p>which contains the logical subscript G. Control will go to rule G.</p>
</div>
<div class="paragraph">
<p>§6.2.3.9 If a list subrule has a right-half, the key will be replaced by what-
ever is written in the right-half. If the number 1 is used in the right-half,
it will refer to the list long symbol, which is the same as the list subrule
left-half.</p>
</div>
<div class="paragraph">
<p>§6.2.4 List Rules for Sorting The subject of efficient sorting is a
very complex one, and one that has developed a considerable
literature. Section 5.2.9 gave a simple interchange method of sorting
according to numerical subscripts.  Additional methods of sorting in
COMIT using numerical subscripts have been described.</p>
</div>
<div class="paragraph">
<p>§6.2.4.1 If the items to be sorted are not already tagged with
numerical sub- scripts that can be used as sort keys, the list rule
provides a ready means for converting alphabetic characters in
constituent symbols into numerical subscripts. Since numerical
subscripts can encode up to 15 binary digits, it is possible to encode
two or three characters in one numerical subscript. To do this, the
characters are looked up one at a time in a list rule and provided
with numerical subscripts within the range of zero to n - 1, where n
is the number of characters in the alphabet used. Then the subscripts
for the several characters are combined by successive multiplication
by n and addition of the subscript for the next character. For
multiplication see section 10.0.8.</p>
</div>
<div class="paragraph">
<p>§6.2.4.2 Alternatively the list rule can provide the nucleus for very
efficient sorting methods that do not utilize numerical
subscripts. One scheme is to bring each item to be sorted into the
workspace and look up one of the characters in the tag or sort
key. The whole item is then thrown on a shelf determined by the result
of the list-rule lookup. Repetition of an inner loop that sorts each
item on one character results in the items being sorted onto n
shelves. They can then be brought off of the shelves in the proper
sort order and the process repeated, sorting on the next character.</p>
</div>
<div class="paragraph">
<p>§6.2.4.3 As an illustration, the following inner loop of a sort program
will sort items according to fixed-length keys using a scheme of
working through the key characters in right-to-left order. Assume that
each of the shelves onto which the items are to be sorted has been
initialized by a constituent having the shelf number as a numerical
subscript (section 5.1.2.1). Items to be sorted are separated by -
characters. Each item consists of first a key of n characters, then a
. character, and then an entry compressed into one constituent.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>- + K + E + Y + . + ENTRY + -</pre>
</div>
</div>
<div class="paragraph">
<p>The inner loop of the routine follows. Start at rule A with the file to be
sorted in the workspace.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>A $1 + $2 + - + $ = // *S3 4 3, *K2, *L1 B
* (finished sorting on this character position)
-B A = // *X11 C
   B = // *X12 C
   .       .
   .       .
   .       .
  - = (finished sorting)
* (character not in list)
C $1 + $ = // *S*1 2 1, *A3 1 A</pre>
</div>
</div>
<div class="paragraph">
<p>§6.2.4.4 Other somewhat similar routines can easily be developed for
left-to-right sorting and for sorting with variable length keys.</p>
</div>
<div class="paragraph">
<p>§6.2.4.5 Such schemes can also be used for numerical sorting where the
numerical key is in the form of constituent symbols instead of
numerical subscripts.  In this case, since there are only 10
characters (digits) in the alphabet, it is possible to sort on two at
once and use 100 shelves with a corresponding improvement in speed and
efficiency.</p>
</div>
<div class="paragraph">
<p>§6.2.4.6 It is also possible to use a variation of this scheme to sort
with a complex or arbitrary sort order or collating sequence, or one
that changes frequently. The actual collating sequence can be varied
by varying the order in which the shelves containing the sorted items
are emptied when the items are gathered up after sorting. This order
can be variable, under the control of a string of constituents on a
pilot shelf. Each constituent would have a different numerical
subscript representing a sort shelf, and the order of the constituents
on the pilot shelf would control the order in which the shelves were
emptied.</p>
</div>
</div>
<div class="sect2">
<h3 id="_6_3_summary_of_new_expressions">6.3 Summary of New Expressions</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">$ go-to</dt>
<dd>
<p>go to the rule named by the subscript of the first constituent
in the group having the relative constituent number l.</p>
</dd>
<dt class="hdlist1">\// <em>SUB V1 V2</em></dt>
<dd>
<p>merge into the dispatcher the subscript <em>SUB</em> with the values
<em>V1</em> and <em>V2</em>.</p>
</dd>
<dt class="hdlist1">\// SUB- V1 V2</dt>
<dd>
<p>merge into the dispatcher the subscript <em>SUB</em> with all values
except <em>V1</em> and <em>V2</em>.</p>
</dd>
<dt class="hdlist1">\// <em>SUB</em></dt>
<dd>
<p>merge into the dispatcher the subscript <em>SUB</em> with no values
(clear it for the subscript <em>SUB</em>).</p>
</dd>
<dt class="hdlist1">\// <em>SUB</em>-</dt>
<dd>
<p>merge into the dispatcher the subscript SUB with all values.</p>
</dd>
<dt class="hdlist1">\// \*D-</dt>
<dd>
<p>clear the dispatcher.</p>
</dd>
<dt class="hdlist1">\// \*Dn</dt>
<dd>
<p>merge into the dispatcher the subscripts on the constituent
with relative constituent number n. i</p>
</dd>
<dt class="hdlist1">\// \*Lcns</dt>
<dd>
<p>look up in the list rule named in the go-to a list long symbol
formed from the workspace expressions referred to by the
consecutive relative constituent numbers cns.</p>
</dd>
<dt class="hdlist1">/ <em>_SUB</em>*D</dt>
<dd>
<p>a right-half expression. Merge into the workspace constituent
the subscript <em>SUB</em> with the values it currently has in
the dispatcher.</p>
</dd>
<dt class="hdlist1">/ $*D</dt>
<dd>
<p>a right-half expression. Merge into the workspace constituent
all the subscripts represented in the dispatcher and having the
values they currently have in the dispatcher.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_6_4_problems_for_chapter_6">6.4 Problems for Chapter 6</h3>
<div class="olist upperalpha">
<ol class="upperalpha">
<li>
<p><a id="question5a"></a> The workspace contains a number of
constituents. Write a routine that will put them all on shelf 23 and
leave a constituent *A in the workspace with a subscript NUMB EVEN or
NUMB ODD, depending on whether the number put on the shelf is even or
odd. Assume EVEN and ODD are the only values ever as- sociated with
the subscript NUMB. <a href="#answer6a">(Answer)</a></p>
</li>
<li>
<p><a id="question6b"></a> Write a test to see if the dispatcher has at
least the value A for the subscript SUB. <a href="#answer6b">(Answer)</a></p>
</li>
<li>
<p><a id="question6c"></a> Write a test to see if there are no values on
the subscript SUB in the dispatcher. <a href="#answer6c">(Answer)</a></p>
</li>
<li>
<p><a id="question6d"></a> There is a rule MAYBE with subrules A, B, C, D,
E, and F; and another rule TRAP. It is not known how the dispatcher
has been set. Write a routine that will go to MAYBE if the dispatcher
has been set for at least one or more of the values A, B, and C; and
arrange it so that the rule MAYBE will choose at random between
subrule D and whichever of the values A, B, and C had been originally
set in the dispatcher. If neither A nor B nor C had originally been
set, go to TRAP. Shelf 23 is empty and may be used if needed.
<a href="#answer6d">(Answer)</a></p>
</li>
<li>
<p><a id="question6e"></a> Write a routine that will send control to YES
with a probability of 0.6 and to NO with a probability of
0.4. <a href="#answer6e">(Answer)</a></p>
</li>
<li>
<p><a id="question6f"></a> A company is looking for a trade name. Write a
routine that will generate at random three-letter words on the
consonant-vowel-consonant pattern, using only the letters A, B, C, D,
E, F, G, L, O, U, and write them out. Use subrules and the<br>
go-to. <a href="#answer6f">(Answer)</a></p>
</li>
<li>
<p><a id="question6g"></a> Suppose you have written a closed subroutine
STPR1, and you desire to test it. Write a program that will test the
subroutine by entering it five times, each time with a different
character A, B, C, D, or E, in the workspace for input data. The test
routine is to put the input data on shelf 1, the output: data from
STPR1 on shelf 2, and call a closed subroutine PRINT each time.
Indicate where the subroutines STPR1 and PRINT are to be inserted.
<a href="#answer6g">(Answer)</a></p>
</li>
<li>
<p><a id="question6h"></a> Each of the five shelves 21, 22, 23, 24, and 25
has a constituent at its left end carrying the shelf number as a
numerical subscript. Write a closed subroutine QUEUE that will queue
the entire contents of the workspace onto one of the shelves,
depending on whether the first constituent in the workspace is ONE,
TWO, THREE, FOUR, or FIVE, respectively. Go to EMPTY if the workspace
is empty and to ERROR if the first constituent is something else.  Use
a list rule. Shelf 20 is empty and can be used. <a href="#answer6h">(Answer)</a></p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_output">OUTPUT</h2>
<div class="sectionbody">
<div class="paragraph">
<p>§7.0.0.0 Up to this point we have dealt with data in the workspace, where it
is manipulated, and on the shelves, where it is out of the way until wanted.
We have yet to discuss in detail how to get data out of the computer so it can
be read or used; that is the topic of this chapter. In a later chapter we will
cover various methods of getting data into the computer.</p>
</div>
<div class="sect2">
<h3 id="_7_1_character_representation">7.1 Character Representation</h3>
<div class="paragraph">
<p>§7.1.0.0 The COMIT system has been designed to offer the programmer as
much flexibility and convenience as possible in arranging his data and
printing it out, or punching it on cards. It is desirable to be able
to print out any of the characters available on the printer. This
means that all the available characters have to be represented in the
workspace. The following is a list of the complete set of (IBM 7094
FORTRAN) characters that a COMIT program can handle as input data or
output data:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>A...Z
. ,
0...9
+ - = *
$ / ( )
blank
end of card or line</pre>
</div>
</div>
<div class="paragraph">
<p>If these characters are all to be handled by COMIT, it must be
possible somehow to represent them all in workspace constituent
symbols and to refer to them all by constituent symbols in the rules
of the COMIT program. But a prob- lem arises since some of the
characters have been set aside for special uses in the rule, notably
the characters + = / * and some others, particularly the numbers 0 -
9. How then will it be possible to write a rule to refer unambiguously
to these characters in the workspace and still be able to use them
unambiguously in their special COMIT meanings? For example, suppose
one wanted to insert into the workspace a constituent with the
character 1 as its symbol.</p>
</div>
<div class="paragraph">
<p>How could this be done since the rule</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ = 1</pre>
</div>
</div>
<div class="paragraph">
<p>means something else? The list of characters that pose problems of
this sort is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>0...9
+ - = *
$ / ( )
blank</pre>
</div>
</div>
<div class="paragraph">
<p>§7.1.1 <strong>Transliteration</strong> The solution has already been hinted at when
it was pointed out that a space (blank) is represented in the
workspace by a hyphen and that the characters + ( and ) are
represented in the workspace as *+ *( and *) respectively. There is a
transliteration that takes place automatically when characters are
read into the workspace as constituent symbols from punched cards or
other external media. Then, during output, when the workspace
characters are printed out or punched on cards, the reverse
transliteration takes place automatically. The above list of problem
characters thus need never be written in the constituent symbol of a
rule. Instead We use a hyphen or minus - for the blank and write
double characters for the others, formed by prefixing asterisks to
them as in the following table:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>*0...*9
*+ *- *= **
*$ */ *( *)
\-</pre>
</div>
</div>
<div class="paragraph">
<p>The required automatic translation of input characters to their
representation in workspace constituent symbols, and the reverse
automatic translation from the workspce representation to output
characters is given in the following table.</p>
</div>
<div class="paragraph">
<p>§7.1.2 Format A Transliteration Table</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Input</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Constituent Symbol</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Output</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(Workspace or rule)</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">A&#8230;&#8203;Z</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A&#8230;&#8203;Z</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A&#8230;&#8203;Z</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">. ,</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">. ,</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">. ,</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0&#8230;&#8203;9</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">*0&#8230;&#8203;*9</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0&#8230;&#8203;9</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">+ - = *</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>+ *- *= *</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">+ - = *</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$ / ( )</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">*$ */ *( *)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">$ / ( )</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">blank</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">blank</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">end of line</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">*.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">end of line</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>§7.1.2.1 The transliteration leaves the letters A &#8230;&#8203; Z and the period
and comma unchanged. A blank and an end of line are represented in the
workspace as - and *. respectively. The ten digits and the remaining
eight special characters are represented in the workspace with a
prefixed asterisk that can be read as "real." Thus the right-half = *1
would mean to insert into the workspace a real one, that is, a
constituent whose symbol would be printed out as 1. The rule for
output transliteration is even simpler: The characters - and *.
become space and end of line; all double characters lose their
asterisks; all other characters are unchanged.</p>
</div>
<div class="paragraph">
<p>§7.1.2.2 It is only in constituent symbols that this transliteration is needed.
The previously described conventions for names still apply: Rule names, subrule
names, subscript names, and value names are up to 12 characters in length and
are composed from the letters, numbers, and, in medial position, periods and
hyphens. Asterisks never appear in names.</p>
</div>
<div class="paragraph">
<p>§7.1.2.3 It is worth noting that when a constituent symbol in the workspace
containing double characters is expanded by executing the routing instruction
*En, each double character remains intact. Thus the workspace constituent
symbol</p>
</div>
<div class="listingblock">
<div class="content">
<pre>AB*1*2*+*3*4</pre>
</div>
</div>
<div class="paragraph">
<p>would become when expanded</p>
</div>
<div class="listingblock">
<div class="content">
<pre>A + B + *1 + *2 + *+ + *3 + *4</pre>
</div>
</div>
<div class="paragraph">
<p>In addition, when any workspace constituents with subscripts are expanded or
compressed, the Subscripts are lost. If it is desired to keep the subscripts,
they can be saved before expanding or compressing by duplicating the constitu-
ents or carrying over the subscripts to other constituents using /$*j in the
right-half.</p>
</div>
<div class="paragraph">
<p>§7.1.2.4 The COMIT programmer obtains an additional bonus from the
transliteration scheme. An extra alphabet *A &#8230;&#8203; *Z is defined for use
in the workspace and in the rules. These characters cannot be
introduced into the workspace from input data in format A, C, or T. If
they appear in the workspace, they must have been inserted from the
right-half of a rule. These double characters have a special important
use. They can be used as markers in the workspace for later
unambiguous reference in a left-half, since they cannot possibly be
con- fused with the input data that is being processed.</p>
</div>
<div class="paragraph">
<p>§7.1.2.5 Normally COMIT makes no distinction between the minus sign
(an 11 punch on the card) and a hyphen (a 4 and 8 punch on the
card). This avoids con- fusion since these characters print the
same. Some key punches and printers, however, have been changed to
print an apostrophe instead of a hyphen. In order to use the
apostrophe as an extra character, one merely has to use a COMSET card
with the word APOSTROPHE on it and a blank in column one. This card
should be inserted between the COM card and the first rule. The
apostrophe is represented as *' in a constituent symbol.</p>
</div>
<div class="paragraph">
<p>§7.1.2.6 As an extra convenience to COMIT programmers who deal
extensively with numbers in constituent symbols, a special abbreviated
notation is avail able that reduces the number of asterisks that have
to be written in the left-half and the right-half. In a left-half or
right-half constituent symbol, it is only the left-most character, if
it is a number, that could be confused with the mention of a relative
constituent number. Therefore the requirement of writing asterisks in
front of "real" numbers in a rule is relaxed except in the case of a
number that is the left-most character of a constituent
symbol. Numbers in the workspace still retain their asterisks, and the
full notation is also still permissible in the rule. Thus the
following pairs are synonymous when written as constituent symbols in
a rule, and either may be used:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>*l*2*3             *123
A*1*2*3            A123
*A*l*2*3           *A123
*1*2*3A            *123A
*1*2*3*A           *123*A
*(*1*2*3*)         *(123*)
*1*2*+*2*3*=*3*5   *12*+23*=35</pre>
</div>
</div>
<div class="paragraph">
<p>(Editor&#8217;s note: This feature is not implemented in COMIT Revived.)</p>
</div>
</div>
<div class="sect2">
<h3 id="_7_2_output_of_symbols">7.2 Output of Symbols</h3>
<div class="paragraph">
<p>§7.2.1 <strong>Format A Output</strong> With the transliteration preliminaries out of the way,
it becomes easy to describe how to program for output.</p>
</div>
<div class="paragraph">
<p>§7.2.1.1 Suppose the programmer wishes to have the output printer print his
name at the top of his pages of printed output. He can use a rule like the
following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $ = -JOHN-DOE*. // *WAM1 *</pre>
</div>
</div>
<div class="paragraph">
<p>The abbreviation *WAM1 in the routing actually causes the writing. The
first character to be written out is a - character, which, when it is
written out in column one, is interpreted by the printer as a code
that causes the printer to move the paper to the next line before
printing. The last character to be written out is a *. double
character, which is the code for end of line. When the whole
constituent is written out it disappears from the workspace. On paper
it will appear as</p>
</div>
<div class="listingblock">
<div class="content">
<pre>JOHN DOE</pre>
</div>
</div>
<div class="paragraph">
<p>since the second - is written as a space.</p>
</div>
<div class="paragraph">
<p>§7.2.1.2 Suppose that a program has produced a lot of text in the workspace as
follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>- T + H + I + S + - + O + U + T + P + U + T + - + T + E + X + T + - +
H + A + S + - + B + E + E + N + - + P + R + O + D + U + C + E + D + - +
B + Y + - + A + - + C + O + M + I + T + - + P + R + O + G + R + A + M +
- + A + N + D + - + I + T + - + I + S + - + D + E + S + I + R + E + D +
- + T + O + - + W + R + I + T + E + - + I + T + - + O + U + T + - + I + N +
- + L + l + N + E + S + - + O + F + - + A + B + O + U + T + - + F + O + R +
+ Y + - + F + I + V + E + - + C + H + A + R + A  + C + T + E + R + S + -
I + N + - + L + E + N + G + T + H + + -</pre>
</div>
</div>
<div class="paragraph">
<p>The following rule will form the text into lines averaging about 45 characters
in length.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $43 + $ + - = 1 + 2 + 3 + *. // *WAM1 2 4 /
* $ = 1 + *.                   // *WAM1 2 *</pre>
</div>
</div>
<div class="paragraph">
<p>The $43 will find the first 43 characters. The $ will find all the rest of the
characters up to the next - between words. The right-half adds an end-of-line
symbol. The write instruction writes out the first, second and fourth constitu-
ents mentioned in the right half. The - is left in the workSpace so that it
will be at the beginning of the next line where it will direct the printer to
move the paper before printing that line. On its first two applications, the
rule will produce the following output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>THIS OUTPUT TEXT HAS BEEN PRODUCED BY A COMIT
PROGRAM AND IT IS DESIRED TO WRITE IT OUT IN</pre>
</div>
</div>
<div class="paragraph">
<p>It is noted that in format A writing all of the + signs between constituents
have been deleted. Subscripts will also be lost, and symbols will be trans-
literated as has been explained.</p>
</div>
<div class="paragraph">
<p>§7.2.1.3 It is not necessary, however, for the COMIT programmer to explicitly
divide his text up into lines by counting characters. The following rule would
put out the entire text, with COMIT automatically breaking it into lines of
convenient length as will be explained in the next section.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $ = 1 + *. // *WAM1 2 *</pre>
</div>
</div>
<div class="paragraph">
<p>§7.2.1.4 We can summarize here some of the output instructions before going on
to a more detailed description of how they work and the kinds of flexibility
they afford.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>*WAM1 2
 │││─┬─
 │││ │
 │││ └── refer to right-half relative constituent numbers
 ││M means monitor output tape
 ││I means output tape for punching
 ││L means on-line printer
 ││P means on-line card punch
 │A means format A, treated here
 │S means format S, treated shortly
*W means write output</pre>
</div>
</div>
<div class="paragraph">
<p>(Editor&#8217;s note: In COMIT Revived, only format A is implemented; format
S was very tied to the IBM 704 batch environment. Channel M is
standard error, all others go to standard output.)</p>
</div>
<div class="paragraph">
<p>§7.2.1.5 In the above illustration, the relative constituent numbers
used refer to workspace constituents by their right-half relative
constituent numbers. The numbers may be used in any order, and the
material is written out in the order indicated. The channel letters M,
l, L, and P are the four that are most frequently used for output,
although other tape units or output devices may occasionally be
referred to by other COMIT channel letters. The usual way to pro- duce
printed output is to write on channel M, which designates the magnetic
tape that COMIT uses as a monitor output tape for compiler and
interpreter error comments. Use of channel M is convenient, for then
all printed output is together. Channel I designates the output tape
used to prepare punched cards and would be used if the programmer
desired some of his results in the form of punched cards. Channels L
and P, for the on-line printer and punch, are less often used because
their extensive use slows the computer down unduly. Usually it is
preferable to write the material quickly on tape and then later have
it printed or punched from the tape while the computer goes on to
other programs.</p>
</div>
<div class="paragraph">
<p>§7.2.2 <strong>Line Length</strong> A single format A write instruction might refer to
any number of workspace constituents and could result in sending to
the output as little as a single character or as much as a dozen or
more pages of text. In case the material sent to the output does not
make up a full line, it may re- quire the execution of a write
instruction several times before a line is completed. Since most of
the output equipment operates on a line-by-line basis, rather than
character by character, COMIT keeps output material of less than a
line length in an area of storage called an output buffer. When the
line is complete, the contents of the buffer are written out on the
appropriate output device. The function of the special workspace
double character *. (end of line) is to cause COMIT to print out as a
line the current contents of the output buffer.</p>
</div>
</div>
<div class="sect2">
<h3 id="_7_3_output_of_constituents">7.3 Output of Constituents</h3>
<div class="paragraph">
<p>§7.3.1 <strong>Format S Output</strong> We have seen how in the case of format A output, plus
signs and subscripts are removed and constituent symbols are transliterated in
a scheme that allows any character to be printed at any point on the page. Thus
the programmer achieves output flexibility. There are times, however, when the
programmer would rather print out or punch out material from the workspace in
workSpace format, untransliterated, complete with plus signs and all subscripts.
For this, format S output is provided. Format S output is a convenient way of
looking at what is going on in a program during debugging. It also has a use in
storing workspace material temporarily on cards or tape for later reading by a
COMIT program. For example, the following rule will print out a copy of the
contents of the workspace and leave the workspace undisturbed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $ = 1 + l // *WSM2 *</pre>
</div>
</div>
<div class="paragraph">
<p>If the workspace contained</p>
</div>
<div class="listingblock">
<div class="content">
<pre>A + B/.3, SUB VALl VAL2 + C + *.</pre>
</div>
</div>
<div class="paragraph">
<p>the rule would print</p>
</div>
<div class="listingblock">
<div class="content">
<pre>A + B/.3, SUB VALl VALZ + C + *.</pre>
</div>
</div>
<div class="paragraph">
<p>whereas, if format A output had been specified instead of format S, the output
would have been</p>
</div>
<div class="listingblock">
<div class="content">
<pre>ABC</pre>
</div>
</div>
<div class="paragraph">
<p>§7.3.1.1 Since format S output does not involve transliteration, any *.
double characters that may occur in constituent symbols are not interpreted
as end-of-line indicators. The length of line is entirely under the control of
the format S bell and margin settings. The standard values are the same as for
format A, namely, 108 and 120 for printing (channels M and L) and 60 and 72
for punching (channels I and P). However, format A and S do differ on channels
other than M, L, I, and P; format A standard settings on other channels are
108 and 120, appropriate for printing, and format S settings are 60 and 72,
appropriate for punching.</p>
</div>
<div class="paragraph">
<p>(Editor&#8217;s note: COMIT Revived does not support Format S.  The
above is included for its historical interest only.)</p>
</div>
</div>
<div class="sect2">
<h3 id="_7_4_some_output_subroutines">7.4 Some Output Subroutines</h3>
<div class="paragraph">
<p>§7.4.0.0 As an illustration of the use of the output instructions, several
typical output subroutines will now be described.</p>
</div>
<div class="paragraph">
<p>§7.4.1 <strong>Output of Text</strong> Suppose one has a program that generates
sentences. The sentences may be of any length and may take up one or
more lines. It is convenient to use a shelf to accumulate the words of
a sentence as they are generated; then, when the sentence is finished,
control is to be sent to a closed subroutine WRITE that will write out
the sentence. For this example we will assume that the normal bell and
margin settings can be used, for no word will be more than 12
characters. The subroutine is</p>
</div>
<div class="listingblock">
<div class="content">
<pre>WRITE $0 = - + 1 + *. // *A23 2, *WAM1 2 3 +</pre>
</div>
</div>
<div class="paragraph">
<p>It is to be noted that a space character is put in column one to cause the
printer to move to the next line before printing the first line of the sentence;
and a *. is provided to end the last line. Each sentence will begin a new line
but will automatically continue onto as many lines as needed.</p>
</div>
<div class="paragraph">
<p>§7.4.2 <strong>Centering Captions</strong> Suppose now that the workspace contains a
short caption of a few words. The caption is expanded so that each
constituent is a letter. It is desired to have a closed Subroutine
CENTER that will write out this caption centered at the top of the
next page. Two solutions are presented here. They both require that
shelf 23 have on it half as many spaces as there are characters in a
full line. The following is a closed subroutine to do that</p>
</div>
<div class="paragraph">
<p>little job-- put 60 spaces on shelf 23.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>60-SPACES $ = ------------ *
* $ = 1 + 1 + 1 + 1 + 1 *
* $ // *El, *Q23 1 +</pre>
</div>
</div>
<div class="paragraph">
<p>§7.4.2.1 The first solution to our subroutine CENTER is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>CENTER $ = - + 1 *
* - + $2 = // *N23 1, *023 2 /
* - + $ = *1 + 1 + 2 + *. // *A23 2, *WAMl 2 3 4 +</pre>
</div>
</div>
<div class="paragraph">
<p>In this routine, one space is taken off the shelf every time two characters of
the caption are added to the right end. In the last rule, everything is brought
from the shelf and written out with a leading *1 to cause the paper to feed to
the top of the next page.</p>
</div>
<div class="paragraph">
<p>§7.4.2.2 The second solution works on the same principle, but uses the compress
instruction:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>CENTER $2 = // *Kl, *Q23 1 /
* $0 = // *A23 1 *
* $ + $60 + $0 = *1 + 2 + *. // *WAM1 2 3 +</pre>
</div>
</div>
<div class="paragraph">
<p>This works because the number of leading spaces needed to center a caption of
n characters is half the line length minus half the number of characters in the
caption, in this case 60 - n/2. The $60 counts out 60 constituents: one for
each two characters in the caption and enough leading spaces to make up 60.</p>
</div>
<div class="paragraph">
<p>§7.4.3 <strong>Aligning Center Words</strong> Our next example is the print routine
for a KWIC program (key word in context), a special index or
concordance program. The input to such a program is a text to be
studied. The program searches the text for occurrences of certain
specified key words. Then it prints out each occurrence found,
together with its surrounding context, for study. The closed print
subroutine shown below writes out one IDS-character line consisting of
50 characters of the preceding context, the key word starting in
character position 51, and with the rest of the line filled with
following context. The routine assumes that the search part of the
program has left at least 50 characters of preceding context on shelf
23 and the key word and its following context, at least 55 characters,
on shelf 24.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>KWIC-PRINT $ =     // *A23 1 *
* $ + $50 + $0 = - + 2 // *WAM1 2, *A24 1 *
* $55 = 1 + *. // *WAM1 2 +</pre>
</div>
</div>
<div class="paragraph">
<p>The second rule of this routine sends the first 50 characters of the line to
the output buffer. The third rule follows it with the rest of the line and an
end-of-line character.</p>
</div>
<div class="paragraph">
<p>§7.4.4 <strong>Printing Columns</strong> The last example is a routine COLUMNS that will print
out tabular material. Assume that the material to be printed in columns con-
sists of words, compressed one word per constituent. Four columns are desired,
each of 15-character width. The material has already been gathered onto shelf
23 in such a way that the first four constituents go on the first line, the
second four go on the second line, and so on. The problem is to provide the
proper number of spaces between items so that the words will start uniformly
in columns 1, 16, 31, and 46.</p>
</div>
<div class="listingblock">
<div class="content">
<pre> COLUMNS $ = // *N23 1 *
* $1 = 1 + --------------- // *EL 2, *Q24 1 COLUMNS
* $0 =     // *A24 1 *
* $ + $-- + $14 + $ + $-- + $14 + $ + $-- + $14 + $ + $-- + $ + - = -
  - + 2   + 3   + 5       + 6       + 8   + 9       + 11  + 12 + *. -
            // *WAMl 2 3 4 5 6 7 8 9 10 /</pre>
</div>
</div>
<div class="paragraph">
<p>The first two rules serve to insert more than enough spaces between each two
items to fill up the space between a word and the one in the next column. It
is worth noting that after the expand instruction operates, the expanded string
of characters and blanks is left with the relative constituent number one. The
shelf instruction then puts it all on the shelf. The fourth rule is hyphenated
onto three cards for clarity. It merely counts out the number of characters for
each column and throws away the extra spaces. The result is written out a line
at a time.</p>
</div>
</div>
<div class="sect2">
<h3 id="_7_5_summary">7.5 Summary</h3>
<div class="paragraph">
<p>§7.5.0.0 Transliteration from input to workspace: letters, period, and comma
are unchanged; blank becomes -; end of line symbol *. added at right end; num-
bers and remaining punctuation characters prefixed with * and become double
characters.</p>
</div>
<div class="paragraph">
<p>§7.5.0.1 Transliteration from workspace to output: - becomes a blank
character; *. signals the end of the line; the * is removed from all
other double characters.</p>
</div>
<div class="paragraph">
<p>§7.5.0.2 Output instructions (ns refers to right-half relative
constituent numbers)</p>
</div>
<div class="listingblock">
<div class="content">
<pre>*WAMns write in format A on the monitor tape (printed output)
*WAIns                          punched output tape
*WALns                          on-line printer
*WAPns                          on-line punch
*WSMns                 S on the monitor tape (printed output)
*WSIns                          punched output tape
*WSLns                          on-line printer
*WSPns                          on-line punch</pre>
</div>
</div>
<div class="paragraph">
<p>For channels M and L, the bell is set at 108 and the margin at 120.
For channels I and P, the bell is set at 60 and the margin at 72.
For other channels, format A bell and margin are 108 and 120,
format S bell and margin are 60 and 72.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_input_subscript_conversion">INPUT SUBSCRIPT CONVERSION</h2>
<div class="sectionbody">
<div class="paragraph">
<p>§8.0.0.0 The facilities for data input in COMIT are extremely
flexible, offer- ing the programmer many options. In this chapter, we
will first describe the standard input facilities, without describing
any of the special options. These standard facilities should be
adequate for many applications. Second, there will be a detailed
discussion of the various special input options available.  Then the
instructions for converting subscripts to symbols and symbols to
subscripts in the workspace will be described. They are described at
this point because they share some of the conventions used in input.</p>
</div>
<div class="sect2">
<h3 id="_8_1_standard_input_facilities">8.1 Standard Input Facilities</h3>
<div class="paragraph">
<p>§8.1.0.0 Data to be read into the workspace is usually in the form of
a deck of punched cards, but it may be material that has been written
out onto tape or other storage medium by a program, or it may result
from typing on a typewriter console. In any case, the data that is to
be read is organized into records and files. A record corresponds to a
line of typing and may consist of the information from one card, or it
may represent a string of up to 3072 char- acters. A file consists of
a group of records terminating in an end-of-file indication. The
end-of-file indication may be the physical end of a deck of cards, it
may be a card with a special punched pattern that varies from one
computer installation to another, or it may be a distinctive mark on
tape.  Whatever the end-of-file indication, COMIT reacts to it in the
same way: The read instruction fails, and control goes to the next
rule.</p>
</div>
<div class="paragraph">
<p>(Editor&#8217;s note: In COMIT Revived, a record is a text line terminated
by newline.  The 3072 length limit is not enforced.)</p>
</div>
<div class="paragraph">
<p>§8.1.1 <strong>Format C Input</strong> One of the easiest ways of providing a COMIT program
with data is to punch the data on cards and place these cards right after the
END card of the program. Suppose, as an example, the data consists of the two
cards:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SOME TEXT $
MORE TEXT.</pre>
</div>
</div>
<div class="paragraph">
<p>The following rules to read this data could be incorporated in the program:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>READ $ = // *RCK1 **
* DONE</pre>
</div>
</div>
<div class="paragraph">
<p>The first time the first rule is executed, it will read the first data card
into the workspace. The workspace will then contain</p>
</div>
<div class="listingblock">
<div class="content">
<pre>S + O + M + E + - + T + E + X + T + - + *$ + *.</pre>
</div>
</div>
<div class="paragraph">
<p>When the card is read, each character goes into the workspace as a single con-
stituent, transliterated according to the scheme of chapter 7.</p>
</div>
<div class="paragraph">
<p>§8.1.1.1 The next time the rule is executed, the workspace would contain</p>
</div>
<div class="listingblock">
<div class="content">
<pre>M + O + R + E + - + T + E + X + T + . + *.</pre>
</div>
</div>
<div class="paragraph">
<p>§8.1.1.2 Then the next time the rule is executed, it would encounter an end-of-
file indication. The behavior of any read instruction on reading an end-of-file
is the same. A null constituent is introduced into the workspace, and the rule
fails in the routing, control going immediately to the next rule. The rest of
the routing and the go-to are not executed.</p>
</div>
<div class="paragraph">
<p>§8.1.1.3 The read instructions are similar to the write instructions. They can
be compactly listed as follows:</p>
</div>
<div class="paragraph">
<p>§8.1 Standard Input Facilities 140</p>
</div>
<div class="listingblock">
<div class="content">
<pre>*RCK1
 ││││
 ││││
 │││└────── refers to a right-half relative constituent number
 ││K means regular input, following the END card of the program
 ││R means on-line card reader
 ││  or other characters for other tape units, etc.
 │C means format C (cards)
 │A means format A (a character per constituent)
 │T means format T (text)
 │S means format S (subscripts)
*R means read input</pre>
</div>
</div>
<div class="paragraph">
<p>(Editor&#8217;s note: in COMIT Revived, K and R are both standard
input. Only formats C and T are implemented.)</p>
</div>
<div class="paragraph">
<p>§8.1.1.4 In the above list, the number refers to a right-half relative constit-
uent number, and it specifies where in the workspace the material is to be put
that has been read. The channel letters K and R designate which input device is
to be read. If K is used, the input cards can be stacked behind the END card
of the COMIT program and read in from the same tape unit.</p>
</div>
<div class="paragraph">
<p>§8.1.2 <strong>Format A Input</strong> Format A input is exactly like format C input except that
it reads only one character each time it is executed, instead of a card or
record.</p>
</div>
<div class="paragraph">
<p>§8.1.3 <strong>Format T Input</strong> Format T input is an input format especially adapted for
large quantities of text. It is fast. It reads a card or record just as format
C does, but instead of bringing in each character as a separate constituent,
it brings in words as separate constituents according to the following simple
scheme: Unbroken strings of letters are compressed into single constituents.
All blanks are deleted. Numbers and punctuation are brought in one character
per constituent. The same transliteration takes place as in formats C and A.
Many flexible options are available for defining how characters are to be
grouped together.</p>
</div>
<div class="paragraph">
<p>§8.1.3.1 As an example, suppose we had the same two data cards as before:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SOME TEXT $
MORE TEXT.</pre>
</div>
</div>
<div class="paragraph">
<p>The following rules would read this data in format T:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>READ $ = // *RTK1 **
* DONE</pre>
</div>
</div>
<div class="paragraph">
<p>The first two times the rule READ is executed, these cards would be read into
the workspace as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SOME + TEXT + *$ + *.</pre>
</div>
</div>
<div class="paragraph">
<p>and</p>
</div>
<div class="listingblock">
<div class="content">
<pre>MORE + TEXT + . + *.</pre>
</div>
</div>
<div class="paragraph">
<p>The third time it is executed, it would put a null constituent into
the workspace; the rule would fail, control going to the next rule.</p>
</div>
<div class="paragraph">
<p>§8.1.3.2 In section 6.2.2 <strong>Input Control of Program</strong>, a subroutine WORD
was assumed, which would read the cards following the END card, obtain
the next word and return control with the word in the workspace, or
return with the workspace empty if an end-of-file is met. The closed
subroutine for this is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>WORD $ = // *N23 1 *
* $-*. = +
* $ = // *RTK1, *823 1, *N23 1 +
* +</pre>
</div>
</div>
<div class="paragraph">
<p>§8.1.3.3 In this routine, the first rule brings the next item off the shelf.
There are three cases: If this item is a constituent and not a *. end-of-record
mark, it is assumed to be a word and control is returned with the word in the
workspace. If the item is a *. or if there was nothing on the shelf, the next
record is read in format T, put on shelf 23, and the first word is put into the
workspace and control is returned. If an end-of-file is encountered, the read
instruction puts a null constituent into the workspace and the rule fails.</p>
</div>
</div>
<div class="sect2">
<h3 id="_8_2_input_options">8.2 Input Options</h3>
<div class="paragraph">
<p>(Editor&#8217;s note: Much of what was in this section was closely tied to
the IBM 704 environment and has been omitted. What remains is not
implemented in COMIT Revived, and probably will not be; it is included
for historical interest only. COMSET cards were facility to pass
directives to COMIT before the program source)</p>
</div>
<div class="paragraph">
<p>§8.2.4 <strong>Format T Options</strong> Format T is especially rich in options. The
available options operate by handling differently characters that
belong to different categories. There are five categories, and each
character is assigned to one category; but a character may be
reassigned by a COMSET card. The five categories and the characters
initially assigned to them are</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">LETTERS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A &#8230;&#8203; Z</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(normally compressed)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">NUMBERS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0 &#8230;&#8203; 9</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(normally expanded)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PUNCTUATION</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">. , ( ) = + - ' / $ *</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(normally expanded)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BLANK</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">the blank</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(normally deleted)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SPECIAL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">none</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>To reassign a character to another category, a COMSET card is used that mentions
the name of the category and the character or characters that are to be changed.
to it. Thus to change the blank and the comma to the category called NUMBERS,
one would use</p>
</div>
<div class="listingblock">
<div class="content">
<pre>NUMBERS BLANK ,</pre>
</div>
</div>
<div class="paragraph">
<p>or to change the asterisk to the SPECIAL category, one would use</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SPECIAL *</pre>
</div>
</div>
<div class="paragraph">
<p>§8.2.4.1 During a format T read operation, unbroken strings of
characters assigned to the LETTERS category are compressed into single
constituents. This method of compressing words into single
constituents is much faster than doing it by a COMIT program after
format C input.</p>
</div>
<div class="paragraph">
<p>§8.2.4.2 The treatment of unbroken strings of characters of other
categories depends on which options are in force, and options can be
changed by COMSET cards. Strings of characters assigned to the NUMBERS
category will be sent to the workspace either in expanded form with
one NUMBER character per constituent or in compressed form with the
string of consecutive NUMBER characters as one constituent. To change
from the normal expanded-form option to the compressed-form option,
the following COMSET can be used:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>K NUMBERS</pre>
</div>
</div>
<div class="paragraph">
<p>To change back to the normal option, the following COMSET can be used:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>E NUMBERS</pre>
</div>
</div>
<div class="paragraph">
<p>Unbroken strings of characters belonging to the PUNCTUATION category
are handled similarly. The relevant COMSET cards are</p>
</div>
<div class="listingblock">
<div class="content">
<pre>K PUNCTUATION
E PUNCTUATION</pre>
</div>
</div>
<div class="paragraph">
<p>The expanded form is the normal option.</p>
</div>
<div class="paragraph">
<p>§8.2.4.3 There are four format T Options concerned with the treatment of blanks
and characters assigned to the BLANK category. The COMSETS for them follow. The
normal option</p>
</div>
<div class="listingblock">
<div class="content">
<pre>NO BLANKS</pre>
</div>
</div>
<div class="paragraph">
<p>deletes characters belonging to this category. The COMSET</p>
</div>
<div class="listingblock">
<div class="content">
<pre>ONE BLANK</pre>
</div>
</div>
<div class="paragraph">
<p>retains as a separate constituent only the first of a string of one or more
BLANK characters. The COMSET</p>
</div>
<div class="listingblock">
<div class="content">
<pre>E BLANKS</pre>
</div>
</div>
<div class="paragraph">
<p>retains each BLANK character as a separate constituent. Finally, the COMSET</p>
</div>
<div class="listingblock">
<div class="content">
<pre>K BLANKS</pre>
</div>
</div>
<div class="paragraph">
<p>retains a string of one or more BLANK characters compressed into a single
constituent.</p>
</div>
<div class="paragraph">
<p>§8.2.4.4 Normally, no characters are assigned to the SPECIAL
category. The assignment of a character such as the asterisk to the
SPECIAL category allows the handling of text punched according to the
format of Newman, Swanson, and Knowlton. footnote[S. M. Newman,
R. W. Swanson, and K. C. Knowlton, "A Notation System for
Transliterating Technical and Scientific Texts for Use in Data
Processing Systems," in Advances in Documentation and Library Science,
ed. Jesse H. Shera (New York: Wiley, 1957-), vol. 3, Information
Retrieval and Machine Translation, pt. 1 (1960), pp. 345-376.] The
processing associated with SPECIAL characters takes precedence over
any other format T options. It is discussed below.</p>
</div>
<div class="paragraph">
<p>§8.2.4.5 One of the ways of punching text on cards is to fill the first
72 columns of each card with text, breaking words without hyphens by
running directly from column 72 of one card to column one of the
next. The advantage of this method of punching is that hyphenation
problems are eliminated and fewer cards are needed for a given
text. The proper COMSET for reading such cards would be CHANNEL K IN
MARGIN 72 FILL LOGICAL</p>
</div>
<div class="paragraph">
<p>§8.2.4.6 But when cards are punched full of text, it is difficult to
make corrections that involve changing the number of characters. The
first function of the SPECIAL character option is to implement a
solution to this problem. Suppose we assign the asterisk to the
SPECIAL category. Then, whenever the asterisk is followed by one or
more spaces or the end of the physical record, it is deleted, along
with the string of spaces. When a correction involves eliminating one
or more characters, the new card is punched and an asterisk punched in
column 72, or earlier, immediately after the shorter corrected
text. Or if the correction involves adding characters, an extra card
must be inserted with a few characters on it followed immediately by
an asterisk and blanks. In either case the effect is as if the text
were again continuous, for the asterisk and the string of blanks
following it are deleted. The text after these deletions is then
further processed. Specifically, a string of letters preceding the
deleted characters, for example, is compressed with a string of
letters following the deleted characters.</p>
</div>
<div class="paragraph">
<p>§8.2.4.7 The other aspect of the SPECIAL character option allows the
special abbreviations and notations proposed by Newman, Swanson, and
Knowlton that make C possible the complete encoding of printed
material, including the indication of capitalization, italics, Greek
letters, and so forth. For example, a single asterisk before a letter
designates an uppercase letter and is not compressed with the
letter. The symbols <strong>( and </strong>) mean, respectively, begin and end a
string of capitalized words; <strong>C means colon; *= and *$ mean begin and
end italics; </strong>Y means the next letter represents a lowercase Greek
letter, and so on.</p>
</div>
<div class="paragraph">
<p>§8.2.4.8 The SPECIAL character option of format T makes it possible to
create such markers as single constituents in the following way: A
string of two or more SPECIAL characters is compressed as a
constituent with the following LETTER, NUMBER, or PUNCTUATION
character. A string of two or more SPECIAL characters followed by a
BLANK or a *. is compressed into a single constituent after the last
special character and any BLANK characters have been deleted. A single
SPECIAL character is compressed with a following PUNCTUATION
character. Other single special characters become single constituents
except those followed by a BLANK or *., which are deleted as explained
above.</p>
</div>
</div>
<div class="sect2">
<h3 id="_8_3_subscript_conversion">8.3 Subscript Conversion</h3>
<div class="paragraph">
<p>§8.3.0.0 At this point we introduce four very handy right-half
subscript instructions. They are related to input and output because
they involve transliteration and the same question of legality of
subscripts that figures in format S input.</p>
</div>
<div class="paragraph">
<p>§8.3.1 <strong>Numerical Subscript to Symbol</strong> If the workspace contains</p>
</div>
<div class="listingblock">
<div class="content">
<pre>A/.286 + B/.100</pre>
</div>
</div>
<div class="paragraph">
<p>and the following rule is executed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* A + B = 1 + 2/*CNS1, .3, SUB *</pre>
</div>
</div>
<div class="paragraph">
<p>the workspace will be left with</p>
</div>
<div class="listingblock">
<div class="content">
<pre>A/.286 + *2*8*6/.3, SUB</pre>
</div>
</div>
<div class="paragraph">
<p>The abbreviation *CNSl means to convert the numerical subscript to a
symbol from the constituent having a left-half relative constituent
number 1, As is clear from the example, the numerical subscript is
transliterated into the workspace notation for a symbol, and this
symbol replaces the number 2 constituent in the workspace. If there is
no such subscript, no operation takes place and there is no error message.</p>
</div>
<div class="paragraph">
<p>§8.3.2 <strong>Symbol to Numerical Subscript</strong> The reverse operation can also be per-
formed. Suppose the workspace contains</p>
</div>
<div class="listingblock">
<div class="content">
<pre>*2*8*6 + A/.100</pre>
</div>
</div>
<div class="paragraph">
<p>and the following rule is executed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $1 + $1 = 1 + 2/*CSN1, .I2 *</pre>
</div>
</div>
<div class="paragraph">
<p>the workspace will be left with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>*2*8*6 + A/.288</pre>
</div>
</div>
<div class="paragraph">
<p>The abbreviation *CSN1 means to <em>c</em>onvert the <em>s</em>ymbol to a
<em>n</em>umerical subscript from the constituent having the left-half
relative constituent number <em>1</em>. The symbol that is to be converted to
a numerical subscript must be such that it
will be a legal numerical subscript, that is, it must be from *8 to *3*2*7*6*7.
It may have leading zeros: That is *0*0*0*0*6 and *0*0*0*1*2*3 would be legal.</p>
</div>
<div class="paragraph">
<p>§8.3.3 <strong>Logical Subscripts to Symbols</strong> Suppose the following constituents have
been placed in the workspace by a right-half expression or by a format S input
operation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>L/.5, A 1 2, B 1 2 + M</pre>
</div>
</div>
<div class="paragraph">
<p>and the following rule is executed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $1 + $1 = 1 + 2/*CLS1, S V *</pre>
</div>
</div>
<div class="paragraph">
<p>The workspace will be left with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>L/.5, A 1 2, B 1 2 + B/S V, 2, 1 + A/2, 1</pre>
</div>
</div>
<div class="paragraph">
<p>The abbreviation *CLS2 means to <em>c</em>onvert the <em>l</em>ogical
<em>s</em>ubscripts into symbols from the constituent having the relative
left-half constituent number <em>i</em>. As can be seen from the example, each
logical subscript becomes a constituent.  Subscript values, if there
are any, become subscript names on the new constituents, and thus
these value names must also be found among the subscript names and
rule names that exist in the program, or there will be an interpreter
error.  Any numerical subscript is not converted. This string of
constituents replaces the currently evolving workspace constituent. If
the *CLS instruction is followed by other subscript instructions,
they operate on the first constituent of the string. If there are no
logical subscripts in the workspace to be converted, no operation
takes place and there is no error message.</p>
</div>
<div class="paragraph">
<p>§8.3.3.1 Note that the constituents formed from the subscripts in the
above example are not in the same order that they were in before being
placed in the workspace. As was explained in section 5.2.5, the order
of subscripts on a con- stituent and the order of values in a logical
subscript are not significant, so that A/S, T is the same as A/T, 8
when written in a rule. Actually, COMIT, for speed of search, keeps
subscripts and values in the workspace in a standard order
depending on the internal numerical code for their names. This order
can be discovered by noting the order of subscripts and values as
printed by a COMDUMP or with format S output. The order of the
constituents obtained by converting two or more subscripts is the same
as the internal order of the subscripts.</p>
</div>
<div class="paragraph">
<p>§8.3.4 <strong>Symbol to Logical Subscripts</strong> If the workspace contains</p>
</div>
<div class="listingblock">
<div class="content">
<pre>A-*l-*2,-B-*3-*4,.*2*5 + C/.5, SUB</pre>
</div>
</div>
<div class="paragraph">
<p>and the following rule is executed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $1 + $1 = 1 + 2/*CSL1, D *</pre>
</div>
</div>
<div class="paragraph">
<p>the workspace will be left with</p>
</div>
<div class="listingblock">
<div class="content">
<pre>A-*l-*2,-B-*3-*4,.*2*5 + C/.25, SUB, D, B 4 3, A 2 1</pre>
</div>
</div>
<div class="paragraph">
<p>The abbreviation *CSL1 means to <em>c</em>onvert the <em>s</em>ymbol into
<em>l</em>ogical (and numerical) subscripts from the constituent having the
left-half relative constituent number <em>1</em>. The symbol to be
converted must be the proper workspace transliteration of a legal
subscript expression. The numerical subscript must be within the
correct range, and the logical subscript names and value names must be
chosen from among those actually used in the program. The converted
subscripts are merged with the other subscripts and values of the
constituent.</p>
</div>
</div>
<div class="sect2">
<h3 id="_8_4_summary">8.4 Summary</h3>
<div class="paragraph">
<p>§8.4.0.0 The following table summarizes the four convert
instructions. In each case the constituent with left-half relative
constituent number n remains unchanged.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">*CNS<em>n</em></dt>
<dd>
<p>convert the numerical subscript from the workspace constituent with
the left-half relative constituent number n to a symbol replacing
the current evolving workspace constituent. If there is no such
subscript, do nothing.</p>
</dd>
<dt class="hdlist1">*CSN<em>n</em></dt>
<dd>
<p>convert the symbol of the workspace constituent with the left-half
relative constituent number n to a numerical subscript and place
it on the current evolving workspace constituent. (The
number must be in the range from 0 to 32767 inclusive.)</p>
</dd>
<dt class="hdlist1">*CLS<em>n</em></dt>
<dd>
<p>convert the logical subscripts of the workspace constituent with
       the left-half relative constituent number n to constituent symbols
       replacing the current evolving workspace constituent. If there are
       no such subscripts, do nothing. Convert the values of each of the
       logical subscripts to subscript names on the appropriate
constituents. (The value names must be legal as subscript
       name in the program.) Additional subscript expressions
       after the *CLS operate on the first of these constituents.</p>
</dd>
<dt class="hdlist1">*CSL<em>n</em></dt>
<dd>
<p>convert the symbol of the workspace constituent with the left-half
       relative constituent number n to logical and numerical subscripts
       and values, and place them on the current evolving workspace
constituent. (The symbol must be the properly transliterated
representation of a legal numerical and logical subscript
       expression that could be read in format S without error.)
Conversion proceeds through the symbol until either the
       end of the symbol or a *+ is reached.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>§8.4.0.1 Summary of input instructions (n refers to a right-half
relative constituent number):</p>
</div>
<div class="listingblock">
<div class="content">
<pre>*RCK__n__ read in format C from the input tape
*RAK__n__                A
*RTK__n__                T
*RSK__n__                S
*RCR__n__                C from the on-line reader
*RAR__n__                A
*RTR__n__                T
*RSR__n__                S</pre>
</div>
</div>
<div class="paragraph">
<p>§8.4.0.2 Summary of input processing steps, in their logical order and
the relevant COMSET cards:</p>
</div>
<div class="paragraph">
<p>For format A, send the record to the input buffer, from which one-character
constituents go to the workspace, one for each read instruction executed.</p>
</div>
<div class="paragraph">
<p>For format C, send the record to the workSpace, one character per
constituent.</p>
</div>
<div class="paragraph">
<p>For format T, execute the SPECIAL character options below and then send the
record to the workspace.</p>
</div>
<div class="paragraph">
<p>If any characters have been assigned to the SPECIAL category:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SPECIAL *</pre>
</div>
</div>
<div class="paragraph">
<p>Assign the * to the SPECIAL category. The normal option is that no
characters are assigned to this category.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">One SPECIAL before LETTERS or NUMBERS: </dt>
<dt class="hdlist1">The SPECIAL becomes a constituent. </dt>
<dd>
<p>One SPECIAL before PUNCTUATION:
   The SPECIAL and one PUNCTUATION become a constituent.</p>
</dd>
<dt class="hdlist1">One SPECIAL before one or more BLANKs: </dt>
<dd>
<p>Delete the SPECIAL and string of BLANKS.</p>
</dd>
<dt class="hdlist1">One SPECIAL before end-of-record (*.): </dt>
<dd>
<p>Delete the SPECIAL.</p>
</dd>
<dt class="hdlist1">String of SPECIALS before LETTERS, NUMBERS, or PUNCTUATION: </dt>
<dd>
<p>The string of SPECIALS and the following character become a constituent.</p>
</dd>
<dt class="hdlist1">String of SPECIALS before one or more BLANKs: </dt>
<dd>
<p>Delete the last SPECIAL and string of BLANKs; the rest of the SPECIALS bei
come a constituent.</p>
</dd>
<dt class="hdlist1">String of SPECIALS before end-of-record (*.): </dt>
<dd>
<p>Delete the last SPECIAL. The rest of the SPECIALS become a constituent.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Then the remaining options in format T: Compress all strings of LETTERS in
single constituents.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>E NUMBERS</pre>
</div>
</div>
<div class="paragraph">
<p>Expand NUMBERS into separate constituents. This is the normal option.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>K NUMBERS</pre>
</div>
</div>
<div class="paragraph">
<p>Compress all strings of NUMBERS into single constituents.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>E PUNCTUATION</pre>
</div>
</div>
<div class="paragraph">
<p>Expand PUNCTUATION into separate constituents. This is the normal option.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>K PUNCTUATION</pre>
</div>
</div>
<div class="paragraph">
<p>Compress all strings of PUNCTUATION into single constituents.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>NO BLANK</pre>
</div>
</div>
<div class="paragraph">
<p>Delete all BLANK characters. This is the normal option.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>ONE BLANK</pre>
</div>
</div>
<div class="paragraph">
<p>In each string of BLANK characters, delete all but one.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>E BLANKS</pre>
</div>
</div>
<div class="paragraph">
<p>Expand BLANKS into separate constituents.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>K BLANKS</pre>
</div>
</div>
<div class="paragraph">
<p>Compress all strings of BLANKS into siigle constituents.</p>
</div>
<div class="paragraph">
<p>§8.4.0.3 Examples of some COMSET cards changing the assignment of characters
to classes are</p>
</div>
<div class="listingblock">
<div class="content">
<pre>LETTERS 3 5
NUMBERS A C E
PUNCTUATION BLANK
BLANKS $ +</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_8_5_problems_for_chapter_8">8.5 Problems for Chapter 8</h3>
<div class="olist upperalpha">
<ol class="upperalpha">
<li>
<p><a id="questiona8a"></a> What would be the best format T options to
read cards containing 10 columns of numbers where it is desired to
ignore sequence numbers?  Assume normal options are in force. Give the
COMSETS to change to the proper options for channel Z. <a href="#answer8a">(Answer)</a></p>
</li>
<li>
<p><a id="question8b"></a> It is desired to read cards with text,
compress words into single constituents, and delete all other
characters. What are the proper COMSETs for format T reading?
<a href="#answer8b">(Answer)</a></p>
</li>
<li>
<p><a id="question8c"></a> The input tape has text on it. It is desired
to use format T to read this text into the workspace one constituent
per character, but abbreviated by re- moving all vowels, A, E, I, 0, U.
Give the COMSETs. <a href="#answer8c">(Answer)</a></p>
</li>
<li>
<p><a id="question8d"></a> A word-count program has counted words of a
text and left the results on shelf 4. For each different word found in
the text, there is a constituent with the word as a symbol and a
numerical subscript for the observed frequency of that word. Example:
THE/.1089. It is desired to print the results with the numbers in
columns 2 through 5 and the words starting in column 10.  Write the
routine. <a href="#answer8d">(Answer)</a></p>
</li>
<li>
<p><a id="question8e"></a> It is desired to read text in format T and
then to convert each word to a subscript name. Write a test to
determine whether a proposed word in the workspace (one constituent)
can safely be converted to a subscript name.  <a href="#answer8e">(Answer)</a></p>
</li>
<li>
<p><a id="question8f"></a> Write a closed subroutine NUMBER that will
return with a new line number or page number as a constituent symbol
in the workspace. Assume that the current number is kept on shelf 25
as a numerical subscript initialized as *N/.1.  <a href="#answer8f">(Answer)</a></p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_appendix">Appendix</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_answers_to_problems_for_chapter_2">Answers to problems for chapter 2</h3>
<div class="paragraph">
<p>A: <a id="answer2a"></a> <a href="#question2a">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>* O + R = 1 + U + 2 *</pre>
</div>
</div>
<div class="paragraph">
<p>B: <a id="answer2b"></a> <a href="#question2b">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>* O + U + R = 1 + 3 /</pre>
</div>
</div>
<div class="paragraph">
<p>C: <a id="answer2c"></a> <a href="#question2c">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>* B = 0 /</pre>
</div>
</div>
<div class="paragraph">
<p>D: <a id="answer2d"></a> <a href="#question2d">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>* B = C /</pre>
</div>
</div>
<div class="paragraph">
<p>E: <a id="answer2e"></a> <a href="#question2e">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>* X + B = 2 + 1 *</pre>
</div>
</div>
<div class="paragraph">
<p>F: <a id="answer2f"></a> <a href="#question2f">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>* B = X + 1 *</pre>
</div>
</div>
<div class="paragraph">
<p>G: <a id="answer2g"></a> <a href="#question2g">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>* X + B = 2 + 1 /</pre>
</div>
</div>
<div class="paragraph">
<p>H: <a id="answer2h"></a> <a href="#question2h">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>LOOP A = B *
* A + X = LOOP</pre>
</div>
</div>
<div class="paragraph">
<p>an alternative solution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* A + X = B + 2 *
* A + B  = B + 2 /</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_answers_to_problems_for_chapter_4">Answers to problems for chapter 4</h3>
<div class="paragraph">
<p>A: <a id="answer4a"></a> <a href="#question4a">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $0 + A + $0 = YES</pre>
</div>
</div>
<div class="paragraph">
<p>B: <a id="answer4b"></a> <a href="#question4b">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $0 + $0 = EMPTY</pre>
</div>
</div>
<div class="paragraph">
<p>C: <a id="answer4c"></a> <a href="#question4c">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $9 $2 + $- A = FIND</pre>
</div>
</div>
<div class="paragraph">
<p>D: <a id="answer4d"></a> <a href="#question4d">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $0 + $2 + $-A = FIND</pre>
</div>
</div>
<div class="paragraph">
<p>E: <a id="answer4e"></a> <a href="#question4e">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $4 + $1 = 1 *</pre>
</div>
</div>
<div class="paragraph">
<p>F: <a id="answer4f"></a> <a href="#question4f">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $1 + $0 = 0</pre>
</div>
</div>
<div class="paragraph">
<p>G: <a id="answer4g"></a> <a href="#question4g">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $-Z + $0 = 1 + Z *</pre>
</div>
</div>
<div class="paragraph">
<p>H: <a id="answer4h"></a> <a href="#question4h">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>* L + $ + L + $1 = 1 + 2 + 4 + 3 *</pre>
</div>
</div>
<div class="paragraph">
<p>I: <a id="answer4i"></a> <a href="#question4i">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $1 + 1 = 1 + 2 + X *</pre>
</div>
</div>
<div class="paragraph">
<p>J: <a id="answer4j"></a> <a href="#question4j">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>* A + A + $ + $-A = l + 4 *</pre>
</div>
</div>
<div class="paragraph">
<p>K: <a id="answer4k"></a> <a href="#question4k">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $0 = // *A23 1 *</pre>
</div>
</div>
<div class="paragraph">
<p>L: <a id="answer4l"></a> <a href="#question4l">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $ + $0 = // *A23 2 *</pre>
</div>
</div>
<div class="paragraph">
<p>M: <a id="answer4m"></a> <a href="#question4m">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>* A + $0 + B = // *N23 2 *</pre>
</div>
</div>
<div class="paragraph">
<p>N: <a id="answer4n"></a> <a href="#question4n">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $ = 1 + 1 // *023 1, *024 2 *</pre>
</div>
</div>
<div class="paragraph">
<p>O: <a id="answer4o"></a> <a href="#question4o">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $0 = // *A22 1, *A23 1, *Q22 1 *</pre>
</div>
</div>
<div class="paragraph">
<p>P: <a id="answer4p"></a> <a href="#question4p">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $0 + $0 + $ = // *A22 1, *A23 2, *Q22 2, *Q23 1 *</pre>
</div>
</div>
<div class="paragraph">
<p>Q: <a id="answer4q"></a> <a href="#question4q">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $0 = // *N23 1, *X23 *</pre>
</div>
</div>
<div class="paragraph">
<p>R: <a id="answer4r"></a> <a href="#question4r">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $0 + $0 + $ = // *N23 1, *N23 2, *X23 *</pre>
</div>
</div>
<div class="paragraph">
<p>S: <a id="answer4s"></a> <a href="#question4s">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $1 = // *S23 1 /
* $  = // *A23 1 *</pre>
</div>
</div>
<div class="paragraph">
<p>T: <a id="answer4t"></a> <a href="#question4t">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>* // *X23 *
* $1 = // *S23 1 /</pre>
</div>
</div>
<div class="paragraph">
<p>U: <a id="answer4u"></a> <a href="#question4u">(Back)</a></p>
</div>
<div class="paragraph">
<p>Solution 1</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $ = // *A12 1 *
* $1 + $ = 1 + 2 + NOT // *Q12 1 2 **
* $ = EMPTY *</pre>
</div>
</div>
<div class="paragraph">
<p>Solution 2</p>
</div>
<div class="listingblock">
<div class="content">
<pre>*      // *X12 *
* $O + $0 = EMPTY **
* $ = 1 + NOT // *Q12 1 *</pre>
</div>
</div>
<div class="paragraph">
<p>Solution 3</p>
</div>
<div class="listingblock">
<div class="content">
<pre>*    // *Xl2 *
* $1 =     // *X12 **
* $ = EMPTY **
* $ = NOT *</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_answers_to_problems_for_chapter_5">Answers to problems for chapter 5</h3>
<div class="paragraph">
<p>A: <a id="answer5a"></a> <a href="#question5a">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>* A/.GO = 1/.D1 LOOP</pre>
</div>
</div>
<div class="paragraph">
<p>B: <a id="answer5b"></a> <a href="#question5b">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>* A/.G36, .L90 = LOOP</pre>
</div>
</div>
<div class="paragraph">
<p>C: <a id="answer5c"></a> <a href="#question5c">(Back)</a></p>
</div>
<div class="paragraph">
<p>First solution</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* A/.L37 = LOOP
* A/.G89 = LOOP</pre>
</div>
</div>
<div class="paragraph">
<p>Second solution</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* A/.G36, .L9O = **
* LOOP</pre>
</div>
</div>
<div class="paragraph">
<p>D: <a id="answer5d"></a> <a href="#question5d">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $1 + $1 + $1 = SUM/.*1, .I.*2, .I.*3 *</pre>
</div>
</div>
<div class="paragraph">
<p>E: <a id="answer5e"></a> <a href="#question5e">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $1 = 1/.1 *
* $1 + $1 = 1 + 2/.*1, .I1 // *Q23 1 /
* $0 = // *A23 1 *</pre>
</div>
</div>
<div class="paragraph">
<p>F: <a id="answer5f"></a> <a href="#question5f">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $0 = A/.0 *
* $0 + $1/.L5 + $ = 2/.I1 + 3 + 3 /
* $1= 0 *</pre>
</div>
</div>
<div class="paragraph">
<p>G: <a id="answer5g"></a> <a href="#question5g">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $1 + $ + $1/.G.*1 = // *Q23 1 2 /
* $0 + $1 =      // *A23 1, *S23 2 *</pre>
</div>
</div>
<div class="paragraph">
<p>H: <a id="answer5h"></a> <a href="#question5h">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $ = A/.51 + B/.55 *
* $1/.G1 + $1 = 1/.D1 + 2/.D1 + $0 // *A*1 3, *Q*2 3 /
* $ = 0 *</pre>
</div>
</div>
<div class="paragraph">
<p>I: <a id="answer5i"></a> <a href="#question5i">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>PUT $0 = // *N20 1 *
* $0 + $1/.L50 + $ = 2/.I1 + 3 // *Q*1 2, *S20 1 +
* $1 =     // *S20 1 FULL
FETCH $0 = // *N20 1 *
* $0 + $1/.G20 = 2 + 2/.D1 // *A*1 1, *S20 2 +
* $1 = // *S20 1 EMPTY</pre>
</div>
</div>
<div class="paragraph">
<p>J: <a id="answer5j"></a> <a href="#question5j">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>* GEORGE/MARRIED YES = YES
*                      NO</pre>
</div>
</div>
<div class="paragraph">
<p>K: <a id="answer5k"></a> <a href="#question5k">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>* GEORGE/EATS- = YES
*                NO</pre>
</div>
</div>
<div class="paragraph">
<p>L: <a id="answer5l"></a> <a href="#question5l">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $1/A + $ + $1/A + $ + $1/A = YES</pre>
</div>
</div>
<div class="paragraph">
<p>M: <a id="answer5m"></a> <a href="#question5m">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $0 + $1 + $1/FURNITURE TABLE DESK = YES</pre>
</div>
</div>
<div class="paragraph">
<p>N: <a id="answer5n"></a> <a href="#question5n">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $1 + 1 = YES</pre>
</div>
</div>
<div class="paragraph">
<p>O: <a id="answer5o"></a> <a href="#question5o">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>SEARCH $1 + $ = // *A22 2 *
* $1 $ + 1 + $1     // *022 2, *023 3 4 /
* $1 $ =      // *022 2 +</pre>
</div>
</div>
<div class="paragraph">
<p>P: <a id="answer5p"></a> <a href="#question5p">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $1 1/Q- C *</pre>
</div>
</div>
<div class="paragraph">
<p>Q: <a id="answer5q"></a> <a href="#question5q">(Back)</a> Because there will then be
no overlap of values and the rule will replace the last subscript
value by all values except this last value.</p>
</div>
<div class="paragraph">
<p>R: <a id="answer5r"></a> <a href="#question5r">(Back)</a> Put on the subscript Q in
the workspace a value Z that is never removed and that has no other
use in the program than to assure an overlap of values.</p>
</div>
<div class="paragraph">
<p>S: <a id="answer5s"></a> <a href="#question5s">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $1 = 1/Q*C, Q- C, Q*C *</pre>
</div>
</div>
<div class="paragraph">
<p>T: When trying to add the last value, or if all values occur originally on Q
and one tries to add C, values would be replaced rather than merged. Q would
end up with only the value C. To prevent this, define a value Z (by mention-
ing it somewhere in the program) that will never be added to the workspace
subscript.</p>
</div>
<div class="paragraph">
<p>U: <a id="answer5u"></a> <a href="#question5u">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $1 + $1/SQUARES*1 = FIT</pre>
</div>
</div>
<div class="paragraph">
<p>V: <a id="answer5v"></a> <a href="#question5v">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>PLAY $1 + $1 l/SQUARES*C + 2 *
* $1 + $1 2/SQUARES*1 +</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_answers_to_problems_for_chapter_6">Answers to problems for chapter 6</h3>
<div class="paragraph">
<p>A: <a id="answer6a"></a> <a href="#question6a">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>$0 - *A/NUMB EVEN *
$1 + $1 = 1/NUMB*C + 2 // *Q23 2 /</pre>
</div>
</div>
<div class="paragraph">
<p>B: <a id="answer6b"></a> <a href="#question6b">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>$0 = *A/SUB*D *
$0 $1/SUB A = 0 YES
$1 0 =          NO</pre>
</div>
</div>
<div class="paragraph">
<p>C: <a id="answer6c"></a> <a href="#question6c">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $0 = *A/SUB*D, SUB*C *
* $0 + $1/SUB- = 0 YES
* $1 = 0           NO</pre>
</div>
</div>
<div class="paragraph">
<p>D: <a id="answer6d"></a> <a href="#question6d">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>* $0 = *A/MAYBE*D *
* $0 + $1/MAYBE A SET
* $0 + $1/MAYBE B SET
* $0 + $1/MAYBE C SET
* TRAP
SET $0 + $1 = 2/MAYBE A B C, MAYBE*C, MAYBE- D, MAYBE*C // *D1, *A23 1 MAYBE</pre>
</div>
</div>
<div class="paragraph">
<p>E: <a id="answer6e"></a> <a href="#question6e">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>A 1  YES
  2  YES
  3  YES
  4  NO
  5  NO</pre>
</div>
</div>
<div class="paragraph">
<p>F: <a id="answer6f"></a> <a href="#question6f">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>START   WORD+WRITE
WORD    *+CONSONANT
*       *+VOWEL
CONSONANT 1 $ + $0 = l + B +
          2        = 1 + C +
          3        = 1 + D +
          4        = 1 + F +
          5        = l + G +
VOWEL 1 $ + $0 = l + A +
      2        = 1 + E +
      3        = 1 + I +
      4        = 1 + O +
      5        = 1 + U +
WRITE $ = - + 1 // *WAM1 2 START</pre>
</div>
</div>
<div class="paragraph">
<p>G: <a id="answer6g"></a> <a href="#question6g">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>* // TEST 1 *
TEST 1 $ = A // TEST 2
     2   = B // TEST 3
     3   = C // TEST 4
     4   = D // TEST 5
     5   = E // TEST 6
     6   DONE
* $ = 1 + 1 // *Q1 1 STRPR1+OUT
OUT $ =     // *Q2 1 PRINT+TEST
(INSERT STRPR1 AND PRINT HERE)
DONE     *</pre>
</div>
</div>
<div class="paragraph">
<p>H: <a id="answer6h"></a> <a href="#question6h">(Back)</a></p>
</div>
<div class="paragraph">
<p>First solution</p>
</div>
<div class="listingblock">
<div class="content">
<pre>QUEUE $1 = // *L1 A
*     EMPTY
-A ONE   = // *X21 **
   TWO   = // *X22 **
   THREE = // *X23 **
   FOUR  = // *X24 **
   FIVE  = // *X25 **
*    ERROR
* $ =    // *S*1 1 +</pre>
</div>
</div>
<div class="paragraph">
<p>Second solution</p>
</div>
<div class="listingblock">
<div class="content">
<pre>QUEUE $1 = // *L1 A
*     EMPTY
-A ONE   = -/.21 **
   TWO   = -/.22 **
   THREE = -/.23 **
   FOUR  = -/.24 **
   FIVE  = -/.25 **
* ERROR
* $1 + $ =     // *Q*1 2, *A20 1</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_answers_to_problems_for_chapter_8">Answers to problems for chapter 8</h3>
<div class="paragraph">
<p>A: <a id="answer8a"></a> <a href="#question8a">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>CHANNEL Z |N MARGIN 72
K NUMBERS</pre>
</div>
</div>
<div class="paragraph">
<p>B: <a id="answer8b"></a> <a href="#question8b">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>BLANK 0 1 2 3
BLANK . , ( ) -</pre>
</div>
</div>
<div class="paragraph">
<p>C: <a id="answer8c"></a> <a href="#question8c">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>BLANK A E I O
NUMBERS BLANK C D F G H J K L M N P Q R S T V W X Y Z</pre>
</div>
</div>
<div class="paragraph">
<p>D: <a id="answer8d"></a> <a href="#question8d">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>PRINT $ = // *N4 1 *
* $1 = ---- + -/*CNSl + 1 // *E1 2 **
*    **
* $ + $5 + $1 + $0 = 2 + ---- + 3 + *. // *WAM1 2 3 4 PRINT</pre>
</div>
</div>
<div class="paragraph">
<p>The routine leaves a blank in column 1 for carriage control.</p>
</div>
<div class="paragraph">
<p>E: <a id="answer8e"></a> <a href="#question8e">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>$0 = A/$*D // *D- *
$1 = 1 + B/$*D // *D1 *
$1 + $1 + $1 = 3 + l/*CLS2 *
$1 + $ + 1 + $ = 1 YES
$1 + $ = 1 NO</pre>
</div>
</div>
<div class="paragraph">
<p>F: <a id="answer8f"></a> <a href="#question8f">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>NUMBER $0 = // *N25 1 *
* $1 = 1/*CNS1 + 1/.I1 // *S25 2 +</pre>
</div>
</div>
<div class="paragraph">
<p>G: <a id="answer8g"></a> <a href="#question8g">(Back)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>     COM RENUMBER
  APOSTROPHE
  LETTERS 0 1 2 3 4 5 6 7 8 9 BLANK
  LETTERS . , ( ) = + - / $ * '
  IN MARGIN 72 FILL
* $ = *N/.1 // *S25 1 *
AGAIN NUMBER+SPACES</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2019-06-13 14:58:26 -0400
</div>
</div>
</body>
</html>