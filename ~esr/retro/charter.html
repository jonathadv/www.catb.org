<html><pre>
Subject: Languages From Hell -- your favorite one could walk again!
Newsgroups: comp.compilers,alt.folklore.computers,comp.lang.misc,comp.unix.wizards

I'm looking for specifications of archaic computer languages.

I write language implementations for fun.  After having written C-INTERCAL and
IEEE PILOT, I have decided that I would like to assemble a sort of living
museum and rogue's gallery of the languages time forgot --- an educational
selection of the freaks, oddities, and horrors from the history of computer
language design.

In addition to my implementations of INTERCAL and PILOT, I have collected
implementations of FOCAL and Trac.  All the code is available for FTP at
locke.ccil.org:pub/retro.  A friend of mind is working on an Algol-60-to-C
translator, and I have been sent a partial BLISS implementation which I may
complete if nothing better offers.

My offer: if you'll send me a redistributable softcopy specification or
manual for a language *you* think is sufficiently perverse to be interesting
and/or of great historical significance, and I agree with you, then I will
implement it!  

Both of the existing Raymond retrocompilers are well documented, including
tour papers that discuss the internals.  Both translate to C as an intermediate
language and call the local C to do code generation, assuring both easy
retargetability and high quality of generated code.  Both may well, in fact,
be the highest-quality implementations in the histories of their respective
languages!  I expect to continue this tradition in future retrocompilers.

To take me up on this special offer, you must supply me with softcopy of a
specification of the language, or at least softcopy of a manual for some
reasonably canonical implementation.  Hardcopy alone is not acceptable, as I am
a poor typist.  You will strengthen your application considerably if you can
include test source or real programs with the spec.  Please do *not* bother
sending me mail that just says "It would be neat if you did X" without
at least pointing me at a softcopy spec or offering to type one in; all
such idle vaporings will be rudely ignored.

This offer is not limited to compiled languages.  I do interpreters too.
In fact, my IEEE PILOT implementation is both a floor wax *and* a dessert
topping...er, that is, both a PILOT compiler *and* a PILOT interpreter.

I am particularly interested in getting specifications and code
samples for the following languages: RPG, 1401 Autocoder, IPL-V, CORAL, and
MAD.  As I pick my next project, candidate specifications will get points for
the following attributes:

   * Intriguing perversity. That is, peculiar control structures, odd storage
     models, entertainingly tortured syntax and lexical rules, etc.

   * Historical interest.  Languages like IPL-V that are remembered as
     failed alternatives to those now living, for example, would get many
     bonus points.  So would languages like MAD, extinct but remembered in
     hacker folklore.

   * Pedagogical interest.  Languages conceived for textbook purposes but
     never implemented, such as Knuth's MIX or Dijkstra's unnamed language
     from "A Discipline Of Programming", would be welcome.

   * Evil reputation.  Preference will be given to languages only spoken
     of in horrified whispers.

   * Being compilable.  Though I will cheerfully do interpreters, I find
     compilers more fun to write.

   * Length of time dead.  All other things being equal, I will prefer
     older designs to newer ones.

   * Quality and completeness of documentation.

   * Availability of test code and sample programs.

Two kinds of language I am *not* generally interested in are assemblers
and MFTLs used by a community of one.  While writing instruction-set emulators
falls within my definition of fun and interesting, I don't care for the kind of
toil involved in simulating port-connected I/O devices and getting ancient
binary formats exactly right.  Nor do I care much about languages only their
inventor ever understood, unless they have some design feature that is
utterly fascinating to *me* (not just the designer).

Possible implementation languages for my retrocompilers and retrointerpreters
may include C, Perl, Scheme, or Emacs Lisp.  All results will be made publicly
available in the retrocomputing archives at locke.ccil.org.

Why am I doing this?  Think of it as performance art.  Or reconstructive
archeology.  Or an excuse to construct educational toys.  Or a kind of arcane
technical joke.  Or a good way to take a break from my serious work when I
can't get away to jam with my musician buddies or windsurf or do karate.  All
these motivations are potent in my mind.

So.  Send me your bizarre computer-language revenants.  I will send high
voltage through their neckbolts and make them live again.
--
				Eric S. Raymond <esr@snark.thyrsus.com>
</pre></html>

